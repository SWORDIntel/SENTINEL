#!/usr/bin/env bash
# Enhanced filesystem search functions with indexing support
# Originally by Jason Thistlethwaite (2013)
# Enhanced for SENTINEL (2024)

# Configuration
SEARCH_INDEX_DIR="${HOME}/.cache/sentinel/search_index"
SEARCH_INDEX_DB="${SEARCH_INDEX_DIR}/mlocate.db"
SEARCH_EXCLUDE_FILE="${SEARCH_INDEX_DIR}/exclude.conf"
SEARCH_UPDATE_INTERVAL=86400  # 24 hours in seconds

# Color definitions
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Create necessary directories
mkdir -p "${SEARCH_INDEX_DIR}"

# Initialize exclude patterns if not exists
if [[ ! -f "${SEARCH_EXCLUDE_FILE}" ]]; then
    cat > "${SEARCH_EXCLUDE_FILE}" << 'EOF'
# Default exclusion patterns
.git
.svn
node_modules
__pycache__
*.pyc
.venv
venv
.env
.idea
.vscode
*.swp
*.tmp
*.temp
*.log
EOF
fi

# Function to check for required tools
check_search_dependencies() {
    local missing=""
    for cmd in locate updatedb find grep rg fd; do
        if ! command -v "$cmd" &>/dev/null; then
            missing+="$cmd "
        fi
    done

    if [[ -n "$missing" ]]; then
        echo -e "${YELLOW}Warning: Some search tools are not installed: ${missing}${NC}"
        echo "For best performance, install missing tools:"
        echo "  Debian/Ubuntu: sudo apt install mlocate ripgrep fd-find"
        echo "  Fedora: sudo dnf install mlocate ripgrep fd-find"
        echo "  Arch: sudo pacman -S mlocate ripgrep fd"
        return 1
    fi
    return 0
}

# Function to update search index
update_search_index() {
    local force="${1:-false}"
    local last_update=0
    
    if [[ -f "${SEARCH_INDEX_DB}" ]]; then
        last_update=$(stat -c %Y "${SEARCH_INDEX_DB}" 2>/dev/null || echo 0)
    fi
    
    local current_time=$(date +%s)
    local time_diff=$((current_time - last_update))
    
    if [[ "$force" == "true" ]] || [[ $time_diff -gt $SEARCH_UPDATE_INTERVAL ]]; then
        echo -e "${BLUE}Updating search index...${NC}"
        if command -v updatedb &>/dev/null; then
            sudo updatedb --output="${SEARCH_INDEX_DB}" \
                         --database-root="${HOME}" \
                         --exclude-from="${SEARCH_EXCLUDE_FILE}" \
                         --prunepaths="$(tr '\n' ' ' < "${SEARCH_EXCLUDE_FILE}" | sed 's/#.*//g')"
            echo -e "${GREEN}Search index updated successfully${NC}"
        else
            echo -e "${YELLOW}Warning: updatedb not found. Install mlocate package for faster searches${NC}"
        fi
    fi
}

# Fast file search using index
ff() {
    local pattern="$1"
    local path="${2:-.}"
    local case_sensitive="${3:-false}"
    
    if [[ -z "$pattern" ]]; then
        echo -e "${RED}Error: Search pattern required${NC}" >&2
        echo "Usage: ff <pattern> [path] [case-sensitive]" >&2
        return 1
    fi
    
    # Update index if needed
    update_search_index
    
    echo -e "${BLUE}Searching for files matching: ${CYAN}$pattern${NC}"
    
    # Try using locate first (fastest)
    if command -v locate &>/dev/null && [[ -f "${SEARCH_INDEX_DB}" ]]; then
        if [[ "$case_sensitive" == "true" ]]; then
            locate -d "${SEARCH_INDEX_DB}" --regex "$pattern"
        else
            locate -d "${SEARCH_INDEX_DB}" -i --regex "$pattern"
        fi
    # Fall back to fd-find if available (faster than find)
    elif command -v fd &>/dev/null; then
        if [[ "$case_sensitive" == "true" ]]; then
            fd "$pattern" "$path"
        else
            fd -i "$pattern" "$path"
        fi
    # Fall back to find as last resort
    else
        if [[ "$case_sensitive" == "true" ]]; then
            find "$path" -name "*${pattern}*"
        else
            find "$path" -iname "*${pattern}*"
        fi
    fi
}

# Search file contents
search_in_files() {
    local pattern="$1"
    local path="${2:-.}"
    local context="${3:-0}"
    local file_pattern="${4:-}"
    
    if [[ -z "$pattern" ]]; then
        echo -e "${RED}Error: Search pattern required${NC}" >&2
        echo "Usage: search_in_files <pattern> [path] [context-lines] [file-pattern]" >&2
        return 1
    fi
    
    echo -e "${BLUE}Searching for content matching: ${CYAN}$pattern${NC}"
    
    # Use ripgrep if available (fastest)
    if command -v rg &>/dev/null; then
        if [[ -n "$file_pattern" ]]; then
            rg --color=always -C "$context" -g "$file_pattern" "$pattern" "$path"
        else
            rg --color=always -C "$context" "$pattern" "$path"
        fi
    # Fall back to grep
    else
        if [[ -n "$file_pattern" ]]; then
            find "$path" -type f -name "$file_pattern" -exec grep --color=always -C "$context" -H "$pattern" {} \;
        else
            grep --color=always -r -C "$context" -H "$pattern" "$path"
        fi
    fi
}

# Find duplicate files
find_duplicates() {
    local path="${1:-.}"
    local min_size="${2:-1M}"
    
    echo -e "${BLUE}Finding duplicate files in: ${CYAN}$path${NC}"
    echo -e "${BLUE}Minimum file size: ${CYAN}$min_size${NC}"
    
    # Use find to get files above min_size, then compare MD5 hashes
    find "$path" -type f -size "+$min_size" -exec md5sum {} \; | \
        sort | \
        uniq -w32 -d --all-repeated=separate | \
        sed 's/^[0-9a-f]*  //'
}

# Find large files
find_large() {
    local path="${1:-.}"
    local min_size="${2:-100M}"
    local limit="${3:-10}"
    
    echo -e "${BLUE}Finding largest files in: ${CYAN}$path${NC}"
    echo -e "${BLUE}Minimum size: ${CYAN}$min_size${NC}"
    echo -e "${BLUE}Limit: ${CYAN}$limit${NC}"
    
    find "$path" -type f -size "+$min_size" -exec ls -lh {} \; | \
        sort -rh -k5 | \
        head -n "$limit" | \
        awk '{print $5 "\t" $9}'
}

# Find recently modified files
find_recent() {
    local path="${1:-.}"
    local days="${2:-1}"
    local limit="${3:-20}"
    
    echo -e "${BLUE}Finding recently modified files in: ${CYAN}$path${NC}"
    echo -e "${BLUE}Within last: ${CYAN}$days days${NC}"
    
    find "$path" -type f -mtime -"$days" -exec ls -lt {} + | \
        head -n "$limit"
}

# Create convenient aliases
alias ffc='ff . true'  # Case-sensitive search
alias ffi='ff . false' # Case-insensitive search (default)
alias search='search_in_files'
alias dupes='find_duplicates'
alias largest='find_large'
alias recent='find_recent'

# Initialize
check_search_dependencies
update_search_index

# Display help information
search_help() {
    cat << EOF
${GREEN}SENTINEL Search Functions${NC}
=======================

${BLUE}File Name Search:${NC}
  ff <pattern> [path] [case-sensitive]  - Search for files by name
  ffc <pattern>                         - Case-sensitive file search
  ffi <pattern>                         - Case-insensitive file search

${BLUE}Content Search:${NC}
  search <pattern> [path] [context] [file-pattern]
                                       - Search file contents

${BLUE}Special Searches:${NC}
  dupes [path] [min-size]              - Find duplicate files
  largest [path] [min-size] [limit]    - Find large files
  recent [path] [days] [limit]         - Find recently modified files

${BLUE}Index Management:${NC}
  update_search_index [force]          - Update search index

${BLUE}Configuration:${NC}
  Index location : ${SEARCH_INDEX_DB}
  Exclude file  : ${SEARCH_EXCLUDE_FILE}
  Update interval: ${SEARCH_UPDATE_INTERVAL} seconds

For detailed examples, use -h or --help with any command
EOF
}

# Add help alias
alias search-help='search_help'

# Add to your search module
search_avx() {
    if ! command -v ugrep &>/dev/null; then
        echo "Installing ugrep for AVX-accelerated searching..."
        sudo apt install ugrep # or appropriate package manager
    fi
    
    # Auto-detect if AVX512 is available
    if grep -q "avx512" /proc/cpuinfo; then
        echo "Using AVX512 acceleration"
        ugrep --cpu=avx2 "$@"  # ugrep automatically uses avx512 when available
    else
        echo "AVX512 not available, falling back to best available SIMD"
        ugrep "$@"  # Uses best available SIMD
    fi
}
