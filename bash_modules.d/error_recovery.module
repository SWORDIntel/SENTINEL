#!/usr/bin/env bash
# SENTINEL - Error Recovery Module
# Version: 1.0.0
# Description: Enhanced error recovery with circuit breaker patterns and graceful degradation
# Dependencies: logging
# Maintainer: SENTINEL Team

# Module metadata for dependency resolution
SENTINEL_MODULE_DESCRIPTION="Enhanced error recovery with circuit breaker and graceful degradation"
SENTINEL_MODULE_VERSION="1.0.0"
SENTINEL_MODULE_DEPENDENCIES="logging"

# Prevent double loading
[[ -n "${_SENTINEL_ERROR_RECOVERY_LOADED}" ]] && return 0
export _SENTINEL_ERROR_RECOVERY_LOADED=1

# Error recovery configuration
: "${SENTINEL_ERROR_RECOVERY_DIR:=$HOME/.sentinel/error_recovery}"
: "${SENTINEL_CIRCUIT_BREAKER_THRESHOLD:=5}"
: "${SENTINEL_CIRCUIT_BREAKER_TIMEOUT:=300}"  # 5 minutes
: "${SENTINEL_ERROR_CONTEXT_LINES:=10}"
: "${SENTINEL_ERROR_REPORT_ENABLED:=1}"
: "${SENTINEL_FALLBACK_MODE:=graceful}"  # graceful, minimal, safe

# Create error recovery directory
mkdir -p "$SENTINEL_ERROR_RECOVERY_DIR"

# Circuit breaker states
declare -gA SENTINEL_CIRCUIT_BREAKERS
declare -gA SENTINEL_CIRCUIT_BREAKER_FAILURES
declare -gA SENTINEL_CIRCUIT_BREAKER_LAST_FAILURE
declare -gA SENTINEL_MODULE_FALLBACKS

# Error context storage
declare -gA SENTINEL_ERROR_CONTEXTS
declare -ga SENTINEL_ERROR_STACK

# Initialize circuit breaker for a component
# Usage: sentinel_circuit_breaker_init <component> [threshold] [timeout]
sentinel_circuit_breaker_init() {
    local component="${1:?Component name required}"
    local threshold="${2:-$SENTINEL_CIRCUIT_BREAKER_THRESHOLD}"
    local timeout="${3:-$SENTINEL_CIRCUIT_BREAKER_TIMEOUT}"
    
    SENTINEL_CIRCUIT_BREAKERS["$component"]="closed"
    SENTINEL_CIRCUIT_BREAKER_FAILURES["$component"]=0
    SENTINEL_CIRCUIT_BREAKER_LAST_FAILURE["$component"]=0
    
    [[ -n "$(type -t sentinel_log_debug)" ]] && \
        sentinel_log_debug "error_recovery" "Circuit breaker initialized for $component (threshold=$threshold, timeout=$timeout)"
}

# Check circuit breaker state
# Usage: sentinel_circuit_breaker_check <component>
# Returns: 0 if closed/half-open (can proceed), 1 if open (should fail fast)
sentinel_circuit_breaker_check() {
    local component="${1:?Component name required}"
    local state="${SENTINEL_CIRCUIT_BREAKERS[$component]:-closed}"
    local last_failure="${SENTINEL_CIRCUIT_BREAKER_LAST_FAILURE[$component]:-0}"
    local current_time=$(date +%s)
    
    case "$state" in
        "closed")
            return 0
            ;;
        "open")
            # Check if timeout has passed
            if (( current_time - last_failure >= SENTINEL_CIRCUIT_BREAKER_TIMEOUT )); then
                # Move to half-open state
                SENTINEL_CIRCUIT_BREAKERS["$component"]="half-open"
                [[ -n "$(type -t sentinel_log_info)" ]] && \
                    sentinel_log_info "error_recovery" "Circuit breaker for $component moved to half-open state"
                return 0
            else
                return 1
            fi
            ;;
        "half-open")
            return 0
            ;;
    esac
}

# Record success for circuit breaker
# Usage: sentinel_circuit_breaker_success <component>
sentinel_circuit_breaker_success() {
    local component="${1:?Component name required}"
    local state="${SENTINEL_CIRCUIT_BREAKERS[$component]:-closed}"
    
    if [[ "$state" == "half-open" ]]; then
        # Reset to closed state
        SENTINEL_CIRCUIT_BREAKERS["$component"]="closed"
        SENTINEL_CIRCUIT_BREAKER_FAILURES["$component"]=0
        [[ -n "$(type -t sentinel_log_info)" ]] && \
            sentinel_log_info "error_recovery" "Circuit breaker for $component reset to closed state"
    fi
}

# Record failure for circuit breaker
# Usage: sentinel_circuit_breaker_failure <component> [error_message]
sentinel_circuit_breaker_failure() {
    local component="${1:?Component name required}"
    local error_message="${2:-Unknown error}"
    local failures="${SENTINEL_CIRCUIT_BREAKER_FAILURES[$component]:-0}"
    local current_time=$(date +%s)
    
    # Increment failure count
    ((failures++))
    SENTINEL_CIRCUIT_BREAKER_FAILURES["$component"]=$failures
    SENTINEL_CIRCUIT_BREAKER_LAST_FAILURE["$component"]=$current_time
    
    # Check if threshold reached
    if (( failures >= SENTINEL_CIRCUIT_BREAKER_THRESHOLD )); then
        SENTINEL_CIRCUIT_BREAKERS["$component"]="open"
        [[ -n "$(type -t sentinel_log_error)" ]] && \
            sentinel_log_error "error_recovery" "Circuit breaker for $component opened after $failures failures: $error_message"
        
        # Trigger fallback if available
        sentinel_trigger_fallback "$component"
    else
        [[ -n "$(type -t sentinel_log_warning)" ]] && \
            sentinel_log_warning "error_recovery" "Component $component failure $failures/$SENTINEL_CIRCUIT_BREAKER_THRESHOLD: $error_message"
    fi
}

# Execute with circuit breaker protection
# Usage: sentinel_with_circuit_breaker <component> <command> [args...]
sentinel_with_circuit_breaker() {
    local component="${1:?Component name required}"
    shift
    local command=("$@")
    
    # Initialize circuit breaker if not exists
    [[ -z "${SENTINEL_CIRCUIT_BREAKERS[$component]}" ]] && sentinel_circuit_breaker_init "$component"
    
    # Check circuit breaker state
    if ! sentinel_circuit_breaker_check "$component"; then
        [[ -n "$(type -t sentinel_log_warning)" ]] && \
            sentinel_log_warning "error_recovery" "Circuit breaker open for $component, failing fast"
        return 1
    fi
    
    # Execute command with error handling
    local start_time=$(date +%s%N)
    local exit_code=0
    
    # Capture error context
    sentinel_capture_error_context "$component" "pre-execution"
    
    # Execute command
    if "${command[@]}"; then
        sentinel_circuit_breaker_success "$component"
    else
        exit_code=$?
        sentinel_circuit_breaker_failure "$component" "Command failed with exit code $exit_code"
        sentinel_capture_error_context "$component" "post-failure"
    fi
    
    # Record execution time
    local end_time=$(date +%s%N)
    local duration=$(( (end_time - start_time) / 1000000 ))  # Convert to milliseconds
    
    [[ -n "$(type -t sentinel_log_debug)" ]] && \
        sentinel_log_debug "error_recovery" "Component $component executed in ${duration}ms (exit code: $exit_code)"
    
    return $exit_code
}

# Register fallback for a module/component
# Usage: sentinel_register_fallback <component> <fallback_function>
sentinel_register_fallback() {
    local component="${1:?Component name required}"
    local fallback_function="${2:?Fallback function required}"
    
    SENTINEL_MODULE_FALLBACKS["$component"]="$fallback_function"
    
    [[ -n "$(type -t sentinel_log_debug)" ]] && \
        sentinel_log_debug "error_recovery" "Registered fallback $fallback_function for $component"
}

# Trigger fallback for a component
# Usage: sentinel_trigger_fallback <component>
sentinel_trigger_fallback() {
    local component="${1:?Component name required}"
    local fallback="${SENTINEL_MODULE_FALLBACKS[$component]}"
    
    if [[ -n "$fallback" ]] && [[ -n "$(type -t "$fallback")" ]]; then
        [[ -n "$(type -t sentinel_log_info)" ]] && \
            sentinel_log_info "error_recovery" "Triggering fallback $fallback for $component"
        
        # Execute fallback
        if "$fallback"; then
            [[ -n "$(type -t sentinel_log_info)" ]] && \
                sentinel_log_info "error_recovery" "Fallback $fallback succeeded for $component"
        else
            [[ -n "$(type -t sentinel_log_error)" ]] && \
                sentinel_log_error "error_recovery" "Fallback $fallback failed for $component"
        fi
    else
        [[ -n "$(type -t sentinel_log_warning)" ]] && \
            sentinel_log_warning "error_recovery" "No fallback registered for $component"
    fi
}

# Capture error context for debugging
# Usage: sentinel_capture_error_context <component> <phase>
sentinel_capture_error_context() {
    local component="${1:?Component name required}"
    local phase="${2:-unknown}"
    local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    
    # Create context entry
    local context_file="$SENTINEL_ERROR_RECOVERY_DIR/${component}_${phase}_$(date +%s).context"
    
    {
        echo "=== Error Context ==="
        echo "Component: $component"
        echo "Phase: $phase"
        echo "Timestamp: $timestamp"
        echo ""
        echo "=== Environment ==="
        echo "Shell: $SHELL"
        echo "PWD: $PWD"
        echo "User: $USER"
        echo ""
        echo "=== Call Stack ==="
        local i=0
        while caller $i > /dev/null 2>&1; do
            caller $i
            ((i++))
        done
        echo ""
        echo "=== Recent Commands ==="
        fc -l -${SENTINEL_ERROR_CONTEXT_LINES} 2>/dev/null || echo "Command history not available"
        echo ""
        echo "=== Module States ==="
        set | grep "^_SENTINEL_.*_LOADED=" | sort
        echo ""
        echo "=== Circuit Breaker States ==="
        for cb in "${!SENTINEL_CIRCUIT_BREAKERS[@]}"; do
            echo "$cb: ${SENTINEL_CIRCUIT_BREAKERS[$cb]} (failures: ${SENTINEL_CIRCUIT_BREAKER_FAILURES[$cb]:-0})"
        done
    } > "$context_file" 2>/dev/null
    
    # Store in memory for quick access
    SENTINEL_ERROR_CONTEXTS["$component"]="$context_file"
}

# Safe module load with fallback
# Usage: sentinel_safe_module_load <module_name> [fallback_function]
sentinel_safe_module_load() {
    local module_name="${1:?Module name required}"
    local fallback_function="${2}"
    
    # Register fallback if provided
    [[ -n "$fallback_function" ]] && sentinel_register_fallback "$module_name" "$fallback_function"
    
    # Try to load module with circuit breaker protection
    sentinel_with_circuit_breaker "$module_name" smart_module_load "$module_name" || {
        local exit_code=$?
        [[ -n "$(type -t sentinel_log_error)" ]] && \
            sentinel_log_error "error_recovery" "Failed to load module $module_name, attempting recovery"
        
        # Try fallback
        sentinel_trigger_fallback "$module_name"
        return $exit_code
    }
}

# Graceful degradation mode manager
# Usage: sentinel_set_degradation_mode <mode>
sentinel_set_degradation_mode() {
    local mode="${1:-graceful}"
    
    case "$mode" in
        "graceful")
            export SENTINEL_FALLBACK_MODE="graceful"
            [[ -n "$(type -t sentinel_log_info)" ]] && \
                sentinel_log_info "error_recovery" "Set degradation mode to graceful - non-critical features may be disabled"
            ;;
        "minimal")
            export SENTINEL_FALLBACK_MODE="minimal"
            [[ -n "$(type -t sentinel_log_warning)" ]] && \
                sentinel_log_warning "error_recovery" "Set degradation mode to minimal - only core features enabled"
            ;;
        "safe")
            export SENTINEL_FALLBACK_MODE="safe"
            [[ -n "$(type -t sentinel_log_warning)" ]] && \
                sentinel_log_warning "error_recovery" "Set degradation mode to safe - maximum stability, minimal features"
            ;;
        *)
            [[ -n "$(type -t sentinel_log_error)" ]] && \
                sentinel_log_error "error_recovery" "Unknown degradation mode: $mode"
            return 1
            ;;
    esac
}

# Check if feature should be enabled based on degradation mode
# Usage: sentinel_feature_available <feature_name> <criticality>
# Criticality: core, important, optional
sentinel_feature_available() {
    local feature="${1:?Feature name required}"
    local criticality="${2:-optional}"
    
    case "$SENTINEL_FALLBACK_MODE" in
        "safe")
            [[ "$criticality" == "core" ]]
            ;;
        "minimal")
            [[ "$criticality" == "core" || "$criticality" == "important" ]]
            ;;
        "graceful"|*)
            return 0  # All features available in graceful mode
            ;;
    esac
}

# Error recovery status report
# Usage: sentinel_error_recovery_status
sentinel_error_recovery_status() {
    echo "=== SENTINEL Error Recovery Status ==="
    echo "Degradation Mode: $SENTINEL_FALLBACK_MODE"
    echo ""
    echo "Circuit Breaker States:"
    for component in "${!SENTINEL_CIRCUIT_BREAKERS[@]}"; do
        local state="${SENTINEL_CIRCUIT_BREAKERS[$component]}"
        local failures="${SENTINEL_CIRCUIT_BREAKER_FAILURES[$component]:-0}"
        printf "  %-20s: %-10s (failures: %d)\n" "$component" "$state" "$failures"
    done
    echo ""
    echo "Registered Fallbacks:"
    for component in "${!SENTINEL_MODULE_FALLBACKS[@]}"; do
        printf "  %-20s: %s\n" "$component" "${SENTINEL_MODULE_FALLBACKS[$component]}"
    done
    echo ""
    echo "Recent Error Contexts:"
    find "$SENTINEL_ERROR_RECOVERY_DIR" -name "*.context" -mtime -1 -exec basename {} \; 2>/dev/null | head -10
}

# Automatic error report generation
# Usage: sentinel_generate_error_report [output_file]
sentinel_generate_error_report() {
    local output_file="${1:-$SENTINEL_ERROR_RECOVERY_DIR/error_report_$(date +%Y%m%d_%H%M%S).txt}"
    
    {
        echo "=== SENTINEL Error Report ==="
        echo "Generated: $(date)"
        echo "System: $(uname -a)"
        echo ""
        sentinel_error_recovery_status
        echo ""
        echo "=== Recent Errors ==="
        if [[ -n "$(type -t sentinel_show_logs)" ]]; then
            sentinel_show_logs all 50 | grep -E "\[(ERROR|CRITICAL)\]" || echo "No recent errors in logs"
        fi
        echo ""
        echo "=== Error Contexts ==="
        for context_file in $(find "$SENTINEL_ERROR_RECOVERY_DIR" -name "*.context" -mtime -1 2>/dev/null | head -5); do
            echo "--- Context: $(basename "$context_file") ---"
            cat "$context_file"
            echo ""
        done
    } > "$output_file"
    
    [[ -n "$(type -t sentinel_log_info)" ]] && \
        sentinel_log_info "error_recovery" "Error report generated: $output_file"
    
    echo "$output_file"
}

# Clean up old error contexts
# Usage: sentinel_cleanup_error_contexts [days]
sentinel_cleanup_error_contexts() {
    local days="${1:-7}"
    
    find "$SENTINEL_ERROR_RECOVERY_DIR" -name "*.context" -mtime "+$days" -delete 2>/dev/null
    
    [[ -n "$(type -t sentinel_log_info)" ]] && \
        sentinel_log_info "error_recovery" "Cleaned up error contexts older than $days days"
}

# Initialize error recovery system
sentinel_init_error_recovery() {
    # Create necessary directories
    mkdir -p "$SENTINEL_ERROR_RECOVERY_DIR"
    
    # Set default degradation mode
    : "${SENTINEL_FALLBACK_MODE:=graceful}"
    
    # Schedule cleanup in background
    (sentinel_cleanup_error_contexts >/dev/null 2>&1 &)
    
    [[ -n "$(type -t sentinel_log_info)" ]] && \
        sentinel_log_info "error_recovery" "Error recovery system initialized (mode: $SENTINEL_FALLBACK_MODE)"
}

# Export functions
export -f sentinel_circuit_breaker_init
export -f sentinel_circuit_breaker_check
export -f sentinel_circuit_breaker_success
export -f sentinel_circuit_breaker_failure
export -f sentinel_with_circuit_breaker
export -f sentinel_register_fallback
export -f sentinel_trigger_fallback
export -f sentinel_capture_error_context
export -f sentinel_safe_module_load
export -f sentinel_set_degradation_mode
export -f sentinel_feature_available
export -f sentinel_error_recovery_status
export -f sentinel_generate_error_report
export -f sentinel_cleanup_error_contexts

# Initialize on load
sentinel_init_error_recovery