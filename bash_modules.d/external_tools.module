#!/usr/bin/env bash
# SENTINEL - External Tools Integration Module
# Version: 1.0.0
# Description: Plugin management and external tool integration system with MCP support
# Dependencies: logging config_cache shell_security
# Maintainer: SENTINEL Team

# Module metadata
SENTINEL_MODULE_DESCRIPTION="External tool integration and plugin management system"
SENTINEL_MODULE_VERSION="1.0.0"
SENTINEL_MODULE_DEPENDENCIES="logging config_cache shell_security"

# Prevent double loading
[[ -n "${_SENTINEL_EXTERNAL_TOOLS_LOADED}" ]] && return 0
export _SENTINEL_EXTERNAL_TOOLS_LOADED=1

# External tools configuration
SENTINEL_TOOLS_DIR="${SENTINEL_TOOLS_DIR:-$HOME/.sentinel/tools}"
SENTINEL_TOOLS_REGISTRY="${SENTINEL_TOOLS_REGISTRY:-$SENTINEL_TOOLS_DIR/registry.json}"
SENTINEL_TOOLS_SANDBOX_DIR="${SENTINEL_TOOLS_SANDBOX_DIR:-$SENTINEL_TOOLS_DIR/sandbox}"
SENTINEL_TOOLS_PLUGINS_DIR="${SENTINEL_TOOLS_PLUGINS_DIR:-$SENTINEL_TOOLS_DIR/plugins}"

# MCP (Model Context Protocol) configuration
SENTINEL_MCP_ENABLED="${SENTINEL_MCP_ENABLED:-1}"
SENTINEL_MCP_SOCKET="${SENTINEL_MCP_SOCKET:-$SENTINEL_TOOLS_DIR/mcp.sock}"
SENTINEL_MCP_TIMEOUT="${SENTINEL_MCP_TIMEOUT:-30}"

# Security settings
SENTINEL_TOOLS_SANDBOX_ENABLED="${SENTINEL_TOOLS_SANDBOX_ENABLED:-1}"
SENTINEL_TOOLS_VERIFICATION="${SENTINEL_TOOLS_VERIFICATION:-1}"
SENTINEL_TOOLS_ALLOWED_COMMANDS="${SENTINEL_TOOLS_ALLOWED_COMMANDS:-git,docker,kubectl,terraform,ansible}"

# Create necessary directories
mkdir -p "$SENTINEL_TOOLS_DIR" "$SENTINEL_TOOLS_SANDBOX_DIR" "$SENTINEL_TOOLS_PLUGINS_DIR"

# Initialize registry if it doesn't exist
if [[ ! -f "$SENTINEL_TOOLS_REGISTRY" ]]; then
    echo '{"tools": {}, "plugins": {}, "version": "1.0.0"}' > "$SENTINEL_TOOLS_REGISTRY"
fi

# Tool discovery function
# Usage: sentinel_tool_discover <path> [type]
sentinel_tool_discover() {
    local search_path="${1:-$PATH}"
    local tool_type="${2:-all}"
    local discovered_tools=()
    
    sentinel_log_info "external_tools" "Discovering tools in: $search_path"
    
    # Split PATH and search for executable tools
    IFS=':' read -ra PATHS <<< "$search_path"
    for path in "${PATHS[@]}"; do
        [[ ! -d "$path" ]] && continue
        
        # Search for known tool patterns
        for tool in $SENTINEL_TOOLS_ALLOWED_COMMANDS; do
            if [[ -x "$path/$tool" ]]; then
                local tool_info=$(sentinel_tool_inspect "$path/$tool")
                if [[ -n "$tool_info" ]]; then
                    discovered_tools+=("$tool_info")
                fi
            fi
        done
    done
    
    # Return discovered tools as JSON array
    printf '{"discovered": [%s]}' "$(IFS=,; echo "${discovered_tools[*]}")"
}

# Tool inspection function
# Usage: sentinel_tool_inspect <tool_path>
sentinel_tool_inspect() {
    local tool_path="$1"
    local tool_name=$(basename "$tool_path")
    local tool_version=""
    local tool_type="binary"
    
    # Try to get version information
    if [[ -x "$tool_path" ]]; then
        # Common version flags
        for flag in --version -v -V version; do
            if tool_version=$("$tool_path" $flag 2>&1 | head -n1); then
                break
            fi
        done
    fi
    
    # Detect tool type
    if [[ "$tool_name" =~ ^(git|gh|hub)$ ]]; then
        tool_type="vcs"
    elif [[ "$tool_name" =~ ^(docker|podman|kubectl|k9s)$ ]]; then
        tool_type="container"
    elif [[ "$tool_name" =~ ^(terraform|ansible|puppet|chef)$ ]]; then
        tool_type="infrastructure"
    elif [[ "$tool_name" =~ ^(npm|yarn|pip|cargo|go)$ ]]; then
        tool_type="package_manager"
    fi
    
    # Return tool information as JSON
    cat <<EOF
{
    "name": "$tool_name",
    "path": "$tool_path",
    "type": "$tool_type",
    "version": "$(echo "$tool_version" | jq -Rs .)",
    "discovered": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF
}

# Tool registration function
# Usage: sentinel_tool_register <name> <path> [metadata]
sentinel_tool_register() {
    local tool_name="$1"
    local tool_path="$2"
    local metadata="${3:-{}}"
    
    [[ -z "$tool_name" || -z "$tool_path" ]] && {
        sentinel_log_error "external_tools" "Tool name and path required for registration"
        return 1
    }
    
    # Verify tool exists and is executable
    if [[ ! -x "$tool_path" ]]; then
        sentinel_log_error "external_tools" "Tool not found or not executable: $tool_path"
        return 1
    fi
    
    # Security verification if enabled
    if [[ "$SENTINEL_TOOLS_VERIFICATION" == "1" ]]; then
        if ! sentinel_tool_verify "$tool_path"; then
            sentinel_log_error "external_tools" "Tool verification failed: $tool_name"
            return 1
        fi
    fi
    
    # Update registry
    local registry_update=$(jq --arg name "$tool_name" \
                              --arg path "$tool_path" \
                              --argjson meta "$metadata" \
                              '.tools[$name] = {
                                  "path": $path,
                                  "metadata": $meta,
                                  "registered": now | strftime("%Y-%m-%dT%H:%M:%SZ"),
                                  "enabled": true
                              }' "$SENTINEL_TOOLS_REGISTRY")
    
    echo "$registry_update" > "$SENTINEL_TOOLS_REGISTRY"
    sentinel_log_info "external_tools" "Registered tool: $tool_name"
    
    # Generate wrapper if sandboxing is enabled
    if [[ "$SENTINEL_TOOLS_SANDBOX_ENABLED" == "1" ]]; then
        sentinel_tool_create_sandbox_wrapper "$tool_name" "$tool_path"
    fi
    
    return 0
}

# Tool verification function
# Usage: sentinel_tool_verify <tool_path>
sentinel_tool_verify() {
    local tool_path="$1"
    local tool_name=$(basename "$tool_path")
    
    # Check if tool is in allowed list
    if [[ ! " $SENTINEL_TOOLS_ALLOWED_COMMANDS " =~ " $tool_name " ]]; then
        sentinel_log_warning "external_tools" "Tool not in allowed list: $tool_name"
        return 1
    fi
    
    # Check file permissions
    local file_perms=$(stat -c %a "$tool_path" 2>/dev/null || stat -f %p "$tool_path" 2>/dev/null)
    if [[ "$file_perms" =~ [2367]$ ]]; then
        sentinel_log_warning "external_tools" "Suspicious permissions on tool: $tool_path"
        return 1
    fi
    
    # Additional security checks can be added here
    
    return 0
}

# Sandbox wrapper creation
# Usage: sentinel_tool_create_sandbox_wrapper <name> <path>
sentinel_tool_create_sandbox_wrapper() {
    local tool_name="$1"
    local tool_path="$2"
    local wrapper_path="$SENTINEL_TOOLS_SANDBOX_DIR/$tool_name"
    
    cat > "$wrapper_path" <<'EOF'
#!/usr/bin/env bash
# SENTINEL sandbox wrapper for: TOOL_NAME

# Sandbox configuration
TOOL_PATH="TOOL_PATH_PLACEHOLDER"
TOOL_NAME="TOOL_NAME_PLACEHOLDER"

# Load SENTINEL security functions
_sentinel_root="${SENTINEL_ROOT:-$HOME/.sentinel}"
_security_module_path=""
if [[ -f "$_sentinel_root/bash_modules.d/shell_security.module" ]]; then
    _security_module_path="$_sentinel_root/bash_modules.d/shell_security.module"
elif [[ -f "$HOME/bash_modules.d/shell_security.module" ]]; then
    _security_module_path="$HOME/bash_modules.d/shell_security.module"
fi
if [[ -n "$_security_module_path" ]]; then
    source "$_security_module_path"
fi

# Pre-execution checks
sentinel_sandbox_pre_exec() {
    # Log execution attempt
    sentinel_log_info "sandbox" "Executing sandboxed tool: $TOOL_NAME"
    
    # Check for suspicious arguments
    for arg in "$@"; do
        if [[ "$arg" =~ (rm|delete|destroy|drop|truncate) ]]; then
            sentinel_log_warning "sandbox" "Potentially dangerous argument detected: $arg"
            read -p "Continue execution? [y/N] " -n 1 -r
            echo
            [[ ! $REPLY =~ ^[Yy]$ ]] && return 1
        fi
    done
    
    return 0
}

# Execute with sandboxing
if sentinel_sandbox_pre_exec "$@"; then
    # Set resource limits if available
    if command -v ulimit >/dev/null 2>&1; then
        ulimit -t 300  # CPU time limit (5 minutes)
        ulimit -v 2097152  # Virtual memory limit (2GB)
    fi
    
    # Execute the actual tool
    exec "$TOOL_PATH" "$@"
else
    exit 1
fi
EOF
    
    # Replace placeholders
    sed -i "s|TOOL_PATH_PLACEHOLDER|$tool_path|g" "$wrapper_path"
    sed -i "s|TOOL_NAME_PLACEHOLDER|$tool_name|g" "$wrapper_path"
    
    chmod +x "$wrapper_path"
    sentinel_log_info "external_tools" "Created sandbox wrapper: $wrapper_path"
}

# MCP (Model Context Protocol) integration
# Usage: sentinel_mcp_init
sentinel_mcp_init() {
    [[ "$SENTINEL_MCP_ENABLED" != "1" ]] && return 0
    
    sentinel_log_info "external_tools" "Initializing MCP integration"
    
    # Create MCP socket directory
    local socket_dir=$(dirname "$SENTINEL_MCP_SOCKET")
    mkdir -p "$socket_dir"
    
    # Start MCP listener if not already running
    if [[ ! -S "$SENTINEL_MCP_SOCKET" ]]; then
        sentinel_mcp_listener &
        local listener_pid=$!
        echo "$listener_pid" > "$SENTINEL_TOOLS_DIR/mcp.pid"
    fi
}

# MCP listener implementation
sentinel_mcp_listener() {
    local socket="$SENTINEL_MCP_SOCKET"
    
    # Clean up old socket if exists
    [[ -S "$socket" ]] && rm -f "$socket"
    
    # Create named pipe for MCP communication
    mkfifo "$socket" 2>/dev/null || {
        sentinel_log_error "external_tools" "Failed to create MCP socket"
        return 1
    }
    
    # Listen for MCP requests
    while true; do
        if read -r request < "$socket"; then
            # Parse MCP request
            local response=$(sentinel_mcp_handle_request "$request")
            echo "$response" > "$socket.response"
        fi
        sleep 0.1
    done
}

# MCP request handler
# Usage: sentinel_mcp_handle_request <request_json>
sentinel_mcp_handle_request() {
    local request="$1"
    local method=$(echo "$request" | jq -r '.method // ""')
    local params=$(echo "$request" | jq -r '.params // {}')
    
    case "$method" in
        "tool.execute")
            local tool_name=$(echo "$params" | jq -r '.tool')
            local tool_args=$(echo "$params" | jq -r '.args[]')
            sentinel_tool_execute "$tool_name" $tool_args
            ;;
        "tool.list")
            sentinel_tool_list_json
            ;;
        "tool.info")
            local tool_name=$(echo "$params" | jq -r '.tool')
            sentinel_tool_info "$tool_name"
            ;;
        *)
            echo '{"error": "Unknown method", "code": -32601}'
            ;;
    esac
}

# Tool execution with logging and sandboxing
# Usage: sentinel_tool_execute <name> [args...]
sentinel_tool_execute() {
    local tool_name="$1"
    shift
    
    # Get tool info from registry
    local tool_info=$(jq -r --arg name "$tool_name" '.tools[$name] // empty' "$SENTINEL_TOOLS_REGISTRY")
    
    if [[ -z "$tool_info" ]]; then
        sentinel_log_error "external_tools" "Tool not registered: $tool_name"
        return 1
    fi
    
    local tool_path=$(echo "$tool_info" | jq -r '.path')
    local enabled=$(echo "$tool_info" | jq -r '.enabled')
    
    if [[ "$enabled" != "true" ]]; then
        sentinel_log_error "external_tools" "Tool is disabled: $tool_name"
        return 1
    fi
    
    # Log execution
    sentinel_log_info "external_tools" "Executing tool: $tool_name $*"
    
    # Execute through sandbox wrapper if enabled
    if [[ "$SENTINEL_TOOLS_SANDBOX_ENABLED" == "1" && -x "$SENTINEL_TOOLS_SANDBOX_DIR/$tool_name" ]]; then
        "$SENTINEL_TOOLS_SANDBOX_DIR/$tool_name" "$@"
    else
        "$tool_path" "$@"
    fi
}

# List registered tools
# Usage: sentinel_tool_list [format]
sentinel_tool_list() {
    local format="${1:-table}"
    
    case "$format" in
        json)
            sentinel_tool_list_json
            ;;
        table|*)
            sentinel_tool_list_table
            ;;
    esac
}

# List tools in JSON format
sentinel_tool_list_json() {
    jq '.tools' "$SENTINEL_TOOLS_REGISTRY"
}

# List tools in table format
sentinel_tool_list_table() {
    echo "Registered External Tools:"
    echo "========================="
    printf "%-20s %-10s %-10s %s\n" "NAME" "TYPE" "ENABLED" "PATH"
    echo "-------------------------------------------------------------------------"
    
    jq -r '.tools | to_entries[] | 
        "\(.key)|\(.value.metadata.type // "unknown")|\(.value.enabled)|\(.value.path)"' \
        "$SENTINEL_TOOLS_REGISTRY" | \
    while IFS='|' read -r name type enabled path; do
        printf "%-20s %-10s %-10s %s\n" "$name" "$type" "$enabled" "$path"
    done
}

# Get tool information
# Usage: sentinel_tool_info <name>
sentinel_tool_info() {
    local tool_name="$1"
    
    jq -r --arg name "$tool_name" '.tools[$name] // {"error": "Tool not found"}' "$SENTINEL_TOOLS_REGISTRY"
}

# Plugin loader
# Usage: sentinel_plugin_load <plugin_name>
sentinel_plugin_load() {
    local plugin_name="$1"
    local plugin_file="$SENTINEL_TOOLS_PLUGINS_DIR/${plugin_name}.plugin"
    
    if [[ ! -f "$plugin_file" ]]; then
        sentinel_log_error "external_tools" "Plugin not found: $plugin_name"
        return 1
    fi
    
    # Source plugin with error handling
    if source "$plugin_file"; then
        sentinel_log_info "external_tools" "Loaded plugin: $plugin_name"
        
        # Register plugin in registry
        jq --arg name "$plugin_name" \
           --arg file "$plugin_file" \
           '.plugins[$name] = {
               "file": $file,
               "loaded": now | strftime("%Y-%m-%dT%H:%M:%SZ"),
               "enabled": true
           }' "$SENTINEL_TOOLS_REGISTRY" > "$SENTINEL_TOOLS_REGISTRY.tmp" && \
        mv "$SENTINEL_TOOLS_REGISTRY.tmp" "$SENTINEL_TOOLS_REGISTRY"
    else
        sentinel_log_error "external_tools" "Failed to load plugin: $plugin_name"
        return 1
    fi
}

# Tool alias creation
# Usage: sentinel_tool_alias <alias_name> <tool_name> [default_args]
sentinel_tool_alias() {
    local alias_name="$1"
    local tool_name="$2"
    shift 2
    local default_args="$*"
    
    # Create alias function
    eval "
    $alias_name() {
        sentinel_tool_execute '$tool_name' $default_args \"\$@\"
    }
    export -f $alias_name
    "
    
    sentinel_log_info "external_tools" "Created alias: $alias_name -> $tool_name $default_args"
}

# Initialize external tools on module load
sentinel_external_tools_init() {
    # Initialize MCP if enabled
    [[ "$SENTINEL_MCP_ENABLED" == "1" ]] && sentinel_mcp_init
    
    # Load registered plugins
    if [[ -f "$SENTINEL_TOOLS_REGISTRY" ]]; then
        local plugins=$(jq -r '.plugins | to_entries[] | select(.value.enabled == true) | .key' "$SENTINEL_TOOLS_REGISTRY" 2>/dev/null)
        for plugin in $plugins; do
            sentinel_plugin_load "$plugin"
        done
    fi
    
    # Auto-discover common tools
    if [[ "${SENTINEL_TOOLS_AUTO_DISCOVER:-1}" == "1" ]]; then
        sentinel_tool_discover "$PATH" >/dev/null 2>&1
    fi
    
    sentinel_log_info "external_tools" "External tools module initialized"
}

# Export functions
export -f sentinel_tool_discover
export -f sentinel_tool_inspect
export -f sentinel_tool_register
export -f sentinel_tool_verify
export -f sentinel_tool_create_sandbox_wrapper
export -f sentinel_mcp_init
export -f sentinel_mcp_listener
export -f sentinel_mcp_handle_request
export -f sentinel_tool_execute
export -f sentinel_tool_list
export -f sentinel_tool_list_json
export -f sentinel_tool_list_table
export -f sentinel_tool_info
export -f sentinel_plugin_load
export -f sentinel_tool_alias
export -f sentinel_external_tools_init

# Initialize module
sentinel_external_tools_init