#!/usr/bin/env bash
# SENTINEL Module: Parallel Module Loader
# Implements parallel loading with dependency graph analysis and caching

SENTINEL_MODULE_DESCRIPTION="Parallel module loading with dependency resolution and caching"
SENTINEL_MODULE_VERSION="1.0.0"
SENTINEL_MODULE_DEPENDENCIES="logging config_cache"

# Cache directory for module metadata
SENTINEL_MODULE_CACHE_DIR="${SENTINEL_MODULE_CACHE_DIR:-$HOME/.cache/sentinel/modules}"
mkdir -p "$SENTINEL_MODULE_CACHE_DIR"

# Timing data storage
declare -A SENTINEL_MODULE_LOAD_TIMES
declare -A SENTINEL_MODULE_CACHE_HITS

# Dependency graph storage
declare -A SENTINEL_MODULE_DEPS_GRAPH
declare -A SENTINEL_MODULE_REVERSE_DEPS

# Module metadata cache
declare -A SENTINEL_MODULE_METADATA_CACHE

# Parallel loading configuration
SENTINEL_PARALLEL_MAX_JOBS="${SENTINEL_PARALLEL_MAX_JOBS:-4}"
SENTINEL_PARALLEL_TIMEOUT="${SENTINEL_PARALLEL_TIMEOUT:-30}"

# Function to calculate file hash for cache validation
_calculate_file_hash() {
    local file="$1"
    if command -v sha256sum &>/dev/null; then
        sha256sum "$file" 2>/dev/null | cut -d' ' -f1
    elif command -v shasum &>/dev/null; then
        shasum -a 256 "$file" 2>/dev/null | cut -d' ' -f1
    else
        # Fallback to modification time
        stat -c %Y "$file" 2>/dev/null || stat -f %m "$file" 2>/dev/null || echo "0"
    fi
}

# Function to load module metadata from cache or file
_load_module_metadata() {
    local module_name="$1"
    local module_file="$2"
    local cache_file="$SENTINEL_MODULE_CACHE_DIR/${module_name}.meta"
    local start_time=$(date +%s%N 2>/dev/null || date +%s)
    
    # Check if module file exists
    if [[ ! -f "$module_file" ]]; then
        return 1
    fi
    
    # Calculate file hash
    local file_hash=$(_calculate_file_hash "$module_file")
    
    # Check cache validity
    if [[ -f "$cache_file" ]]; then
        local cached_hash=$(head -n1 "$cache_file" 2>/dev/null)
        if [[ "$cached_hash" == "$file_hash" ]]; then
            # Cache hit - load from cache
            SENTINEL_MODULE_CACHE_HITS["$module_name"]=1
            local metadata=$(tail -n +2 "$cache_file")
            SENTINEL_MODULE_METADATA_CACHE["$module_name"]="$metadata"
            
            # Parse dependencies from cache
            local deps=$(echo "$metadata" | grep "^DEPS:" | cut -d':' -f2-)
            if [[ -n "$deps" ]]; then
                SENTINEL_MODULE_DEPS_GRAPH["$module_name"]="$deps"
            fi
            
            local end_time=$(date +%s%N 2>/dev/null || date +%s)
            local duration=$((($end_time - $start_time) / 1000000)) # Convert to milliseconds
            [[ "${SENTINEL_DEBUG_MODULES:-0}" == "1" ]] && echo "DEBUG: Metadata cache hit for $module_name (${duration}ms)" >&2
            
            return 0
        fi
    fi
    
    # Cache miss - parse module file
    local description=""
    local version=""
    local dependencies=""
    
    # Extract metadata with single file read
    while IFS= read -r line; do
        case "$line" in
            *"SENTINEL_MODULE_DESCRIPTION="*)
                description="${line#*SENTINEL_MODULE_DESCRIPTION=}"
                description="${description//\"/}"
                ;;
            *"SENTINEL_MODULE_VERSION="*)
                version="${line#*SENTINEL_MODULE_VERSION=}"
                version="${version//\"/}"
                ;;
            *"SENTINEL_MODULE_DEPENDENCIES="*)
                dependencies="${line#*SENTINEL_MODULE_DEPENDENCIES=}"
                dependencies="${dependencies//\"/}"
                ;;
        esac
        
        # Stop parsing after finding all metadata
        if [[ -n "$description" && -n "$version" && -n "$dependencies" ]]; then
            break
        fi
    done < "$module_file"
    
    # Build metadata
    local metadata="DESC:$description
VER:$version
DEPS:$dependencies
FILE:$module_file"
    
    # Store in memory cache
    SENTINEL_MODULE_METADATA_CACHE["$module_name"]="$metadata"
    
    # Store dependencies in graph
    if [[ -n "$dependencies" ]]; then
        SENTINEL_MODULE_DEPS_GRAPH["$module_name"]="$dependencies"
        
        # Build reverse dependency graph
        for dep in $dependencies; do
            local current_reverse="${SENTINEL_MODULE_REVERSE_DEPS[$dep]}"
            if [[ -n "$current_reverse" ]]; then
                SENTINEL_MODULE_REVERSE_DEPS["$dep"]="$current_reverse $module_name"
            else
                SENTINEL_MODULE_REVERSE_DEPS["$dep"]="$module_name"
            fi
        done
    fi
    
    # Write to cache file
    {
        echo "$file_hash"
        echo "$metadata"
    } > "$cache_file" 2>/dev/null
    
    local end_time=$(date +%s%N 2>/dev/null || date +%s)
    local duration=$((($end_time - $start_time) / 1000000))
    [[ "${SENTINEL_DEBUG_MODULES:-0}" == "1" ]] && echo "DEBUG: Metadata parsed for $module_name (${duration}ms)" >&2
    
    return 0
}

# Function to build complete dependency graph
_build_dependency_graph() {
    local module_path="${1:-$SENTINEL_MODULES_PATH}"
    local start_time=$(date +%s%N 2>/dev/null || date +%s)
    
    echo "Building module dependency graph..." >&2
    
    # Find all modules
    local modules=()
    while IFS= read -r module_file; do
        [[ -z "$module_file" ]] && continue
        local module_name=$(basename "$module_file" | sed 's/\.\(module\|sh\)$//')
        modules+=("$module_name:$module_file")
    done < <(find "$module_path" -maxdepth 3 -type f \( -name "*.module" -o -name "*.sh" \) 2>/dev/null | sort)
    
    # Load metadata for all modules in parallel (using process substitution)
    local count=0
    for module_info in "${modules[@]}"; do
        local module_name="${module_info%%:*}"
        local module_file="${module_info#*:}"
        
        # Load metadata (this will use cache if available)
        _load_module_metadata "$module_name" "$module_file" >/dev/null 2>&1 &
        
        # Limit parallel jobs
        ((count++))
        if (( count % SENTINEL_PARALLEL_MAX_JOBS == 0 )); then
            wait
        fi
    done
    wait
    
    local end_time=$(date +%s%N 2>/dev/null || date +%s)
    local duration=$((($end_time - $start_time) / 1000000))
    echo "Dependency graph built in ${duration}ms" >&2
}

# Function to perform topological sort on dependency graph
_topological_sort() {
    local -A in_degree
    local -A visited
    local -a zero_degree
    local -a sorted_order
    
    # Calculate in-degree for each module
    for module in "${!SENTINEL_MODULE_DEPS_GRAPH[@]}"; do
        in_degree["$module"]=0
        visited["$module"]=0
    done
    
    # Count incoming edges
    for module in "${!SENTINEL_MODULE_DEPS_GRAPH[@]}"; do
        local deps="${SENTINEL_MODULE_DEPS_GRAPH[$module]}"
        for dep in $deps; do
            if [[ -n "$dep" ]]; then
                ((in_degree["$dep"]++))
            fi
        done
    done
    
    # Find all modules with no dependencies
    for module in "${!in_degree[@]}"; do
        if [[ "${in_degree[$module]}" -eq 0 ]]; then
            zero_degree+=("$module")
        fi
    done
    
    # Process modules in topological order
    while [[ ${#zero_degree[@]} -gt 0 ]]; do
        local current="${zero_degree[0]}"
        zero_degree=("${zero_degree[@]:1}")
        sorted_order+=("$current")
        
        # Check modules that depend on current
        local reverse_deps="${SENTINEL_MODULE_REVERSE_DEPS[$current]}"
        for dependent in $reverse_deps; do
            ((in_degree["$dependent"]--))
            if [[ "${in_degree[$dependent]}" -eq 0 ]]; then
                zero_degree+=("$dependent")
            fi
        done
    done
    
    # Return sorted order
    printf '%s\n' "${sorted_order[@]}"
}

# Function to identify independent module groups for parallel loading
_identify_parallel_groups() {
    local -a sorted_modules
    mapfile -t sorted_modules < <(_topological_sort)
    
    local -A module_level
    local max_level=0
    
    # Assign levels based on dependencies
    for module in "${sorted_modules[@]}"; do
        local level=0
        local deps="${SENTINEL_MODULE_DEPS_GRAPH[$module]}"
        
        for dep in $deps; do
            if [[ -n "$dep" && -n "${module_level[$dep]}" ]]; then
                local dep_level="${module_level[$dep]}"
                if (( dep_level >= level )); then
                    level=$((dep_level + 1))
                fi
            fi
        done
        
        module_level["$module"]=$level
        if (( level > max_level )); then
            max_level=$level
        fi
    done
    
    # Group modules by level
    local -a parallel_groups
    for ((i=0; i<=max_level; i++)); do
        local group=""
        for module in "${!module_level[@]}"; do
            if [[ "${module_level[$module]}" -eq $i ]]; then
                group="$group $module"
            fi
        done
        if [[ -n "$group" ]]; then
            parallel_groups+=("$group")
        fi
    done
    
    # Return groups
    printf '%s\n' "${parallel_groups[@]}"
}

# Function to load a single module with timing
_load_module_with_timing() {
    local module_name="$1"
    local module_file="$2"
    local start_time=$(date +%s%N 2>/dev/null || date +%s)
    
    # Load the module
    if [[ -f "$module_file" ]]; then
        source "$module_file" 2>/dev/null || {
            echo "ERROR: Failed to load module $module_name" >&2
            return 1
        }
        
        # Mark as loaded
        SENTINEL_LOADED_MODULES["$module_name"]=1
        
        local end_time=$(date +%s%N 2>/dev/null || date +%s)
        local duration=$((($end_time - $start_time) / 1000000))
        SENTINEL_MODULE_LOAD_TIMES["$module_name"]=$duration
        
        [[ "${SENTINEL_DEBUG_MODULES:-0}" == "1" ]] && echo "DEBUG: Loaded $module_name in ${duration}ms" >&2
        return 0
    else
        echo "ERROR: Module file not found: $module_file" >&2
        return 1
    fi
}

# Function to load modules in parallel groups
parallel_load_modules() {
    local module_list="${1:-$HOME/.enabled_modules}"
    local start_time=$(date +%s%N 2>/dev/null || date +%s)
    
    if [[ "${SENTINEL_QUIET_MODE:-0}" != "1" && "${SENTINEL_SUPPRESS_MODULE_MESSAGES:-0}" != "1" ]]; then
        echo "=== SENTINEL Parallel Module Loader ===" >&2
    fi
    
    # Build dependency graph
    _build_dependency_graph
    
    # Get modules to load
    local -A modules_to_load
    if [[ -f "$module_list" ]]; then
        while IFS= read -r module_name; do
            [[ -z "$module_name" || "$module_name" =~ ^# ]] && continue
            
            # Skip if already loaded
            if [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "1" ]]; then
                continue
            fi
            
            # Skip lazy modules during startup
            if is_lazy_load_module "$module_name"; then
                create_lazy_proxy "$module_name" "$module_file"
                SENTINEL_LOADED_MODULES["$module_name"]="lazy"
                continue
            fi
            
            modules_to_load["$module_name"]=1
        done < "$module_list"
    fi
    
    # Identify parallel groups
    local -a parallel_groups
    mapfile -t parallel_groups < <(_identify_parallel_groups)
    
    echo "Loading modules in ${#parallel_groups[@]} parallel groups..." >&2
    
    # Load each group
    local total_loaded=0
    for ((i=0; i<${#parallel_groups[@]}; i++)); do
        local group="${parallel_groups[$i]}"
        echo "Loading group $((i+1)): $group" >&2
        
        # Load modules in this group in parallel
        for module_name in $group; do
            if [[ -n "${modules_to_load[$module_name]}" ]]; then
                # Get module file from metadata
                local metadata="${SENTINEL_MODULE_METADATA_CACHE[$module_name]}"
                local module_file=$(echo "$metadata" | grep "^FILE:" | cut -d':' -f2-)
                
                if [[ -n "$module_file" ]]; then
                    _load_module_with_timing "$module_name" "$module_file" &
                    ((total_loaded++))
                fi
            fi
        done
        
        # Wait for this group to complete
        wait
    done
    
    local end_time=$(date +%s%N 2>/dev/null || date +%s)
    local total_duration=$((($end_time - $start_time) / 1000000))
    
    # Print summary
    echo "=== Module Loading Summary ===" >&2
    echo "Total time: ${total_duration}ms" >&2
    echo "Modules loaded: $total_loaded" >&2
    echo "Cache hits: ${#SENTINEL_MODULE_CACHE_HITS[@]}" >&2
    
    # Show slowest modules
    if [[ ${#SENTINEL_MODULE_LOAD_TIMES[@]} -gt 0 ]]; then
        echo "Slowest modules:" >&2
        for module in "${!SENTINEL_MODULE_LOAD_TIMES[@]}"; do
            echo "  $module: ${SENTINEL_MODULE_LOAD_TIMES[$module]}ms"
        done | sort -t':' -k2 -nr | head -5 >&2
    fi
    
    return 0
}

# Function to invalidate cache for a specific module
invalidate_module_cache() {
    local module_name="$1"
    local cache_file="$SENTINEL_MODULE_CACHE_DIR/${module_name}.meta"
    
    if [[ -f "$cache_file" ]]; then
        rm -f "$cache_file"
        echo "Cache invalidated for module: $module_name" >&2
    fi
    
    # Clear from memory cache
    unset "SENTINEL_MODULE_METADATA_CACHE[$module_name]"
    unset "SENTINEL_MODULE_DEPS_GRAPH[$module_name]"
}

# Function to clear all module caches
clear_module_cache() {
    rm -rf "$SENTINEL_MODULE_CACHE_DIR"/*
    
    # Clear memory caches
    unset SENTINEL_MODULE_METADATA_CACHE
    unset SENTINEL_MODULE_DEPS_GRAPH
    unset SENTINEL_MODULE_REVERSE_DEPS
    
    declare -A SENTINEL_MODULE_METADATA_CACHE
    declare -A SENTINEL_MODULE_DEPS_GRAPH
    declare -A SENTINEL_MODULE_REVERSE_DEPS
    
    echo "All module caches cleared" >&2
}

# Function to show module dependency graph
show_module_dependencies() {
    local module_name="$1"
    
    if [[ -z "$module_name" ]]; then
        # Show all dependencies
        echo "=== Module Dependency Graph ===" >&2
        for module in "${!SENTINEL_MODULE_DEPS_GRAPH[@]}"; do
            local deps="${SENTINEL_MODULE_DEPS_GRAPH[$module]}"
            if [[ -n "$deps" ]]; then
                echo "$module -> $deps" >&2
            else
                echo "$module (no dependencies)" >&2
            fi
        done
    else
        # Show dependencies for specific module
        local deps="${SENTINEL_MODULE_DEPS_GRAPH[$module_name]}"
        local reverse_deps="${SENTINEL_MODULE_REVERSE_DEPS[$module_name]}"
        
        echo "=== Dependencies for $module_name ===" >&2
        echo "Depends on: ${deps:-none}" >&2
        echo "Required by: ${reverse_deps:-none}" >&2
    fi
}

# Export functions for use by module system
export -f parallel_load_modules
export -f invalidate_module_cache
export -f clear_module_cache
export -f show_module_dependencies

# Alias for convenience
alias modules-parallel='parallel_load_modules'
alias modules-cache-clear='clear_module_cache'
alias modules-deps='show_module_dependencies'

if [[ "${SENTINEL_QUIET_MODE:-0}" != "1" && "${SENTINEL_SUPPRESS_MODULE_MESSAGES:-0}" != "1" ]]; then
    echo "SENTINEL Parallel Module Loader initialized" >&2
fi