#!/bin/bash

# sentinel-completion.bash

_sentinel_completions() {
    local cur prev words cword
    _get_comp_words_by_ref -n =: cur prev words cword

    # Ensure standard completion functions are available
    # Try to source bash_completion if _filedir is not defined.
    if ! type _filedir &>/dev/null; then
        if [[ -f /usr/share/bash-completion/bash_completion ]]; then
            source /usr/share/bash-completion/bash_completion
        elif [[ -f /etc/bash_completion ]]; then
            source /etc/bash_completion
        fi
    fi

    local opts_global="--verbose --config"
    # This should ideally be dynamically generated by sentinel itself
    # e.g. sentinel --list-subcommands
    local subcommands="module process help"
    local module_actions="list load unload"

    # Dummy list for prototype. In a real scenario, these could be dynamic.
    # e.g., sentinel module --list-available
    local available_modules="alpha beta gamma"

    # Path to the file storing loaded modules (consistent with sentinel script prototype)
    local loaded_modules_file="/tmp/sentinel_loaded_modules.txt"


    # First word: completing "sentinel" itself or its first argument
    if [[ "$cword" -le 1 ]]; then
        COMPREPLY=( $(compgen -W "${opts_global} ${subcommands}" -- "$cur") )
        return 0
    fi

    local cmd="${words[1]}" # The subcommand or first global option

    # Handle completion for arguments of global options if they appear first
    if [[ "$cmd" == "--config" && "$cword" -eq 2 ]]; then
        _filedir "$cur" # Pass current word to _filedir for partial path completion
        return 0
    fi

    # If current word is an option, suggest global options or subcommand specific options
    if [[ "$cur" == -* ]]; then
        local current_subcommand=""
        # Determine if we are in a subcommand context
        for ((i=1; i<cword; i++)); do
            # Check if words[i] is one of the known subcommands
            if [[ " ${subcommands[*]} " =~ " ${words[i]} " ]]; then
                current_subcommand="${words[i]}"
                break
            fi
        done

        local opts_specific=""
        if [[ "$current_subcommand" == "module" ]]; then
            # Add module-specific options here if any (none for this prototype)
            opts_specific=""
        elif [[ "$current_subcommand" == "process" ]]; then
            # For 'process', argcomplete should handle options.
            # This part of bash-completion script should ideally not list them
            # to avoid conflict or duplicate suggestions with argcomplete.
            COMPREPLY=()
            return 0
        elif [[ "$current_subcommand" == "help" ]]; then
            # 'help' subcommand itself doesn't have options, it takes a subcommand name
            COMPREPLY=()
            return 0
        fi

        COMPREPLY=( $(compgen -W "${opts_global} ${opts_specific}" -- "$cur") )
        return 0
    fi

    # Subcommand specific completion
    case "$cmd" in
        module)
            local action_word_idx=2 # `sentinel module <action>`
            if [[ "$cword" -eq "$action_word_idx" ]]; then # Completing the action itself
                COMPREPLY=( $(compgen -W "${module_actions}" -- "$cur") )
            elif [[ "$cword" -gt "$action_word_idx" ]]; then
                local current_action="${words[$action_word_idx]}"
                case "$current_action" in
                    load)
                        if [[ "$cword" -eq $((action_word_idx + 1)) ]]; then
                            COMPREPLY=( $(compgen -W "${available_modules}" -- "$cur") )
                        fi
                        ;;
                    unload)
                        if [[ "$cword" -eq $((action_word_idx + 1)) ]]; then
                            if [[ -f "$loaded_modules_file" ]]; then
                                local loaded_modules=$(cat "$loaded_modules_file")
                                COMPREPLY=( $(compgen -W "${loaded_modules}" -- "$cur") )
                            else
                                COMPREPLY=() # No file, no completions
                            fi
                        fi
                        ;;
                    list)
                        COMPREPLY=() # "list" takes no arguments
                        ;;
                esac
            fi
            ;;
        process)
            # Bash completion for the 'process' subcommand.
            # The first argument to 'process' is a file path.
            if [[ "$cword" -eq 2 ]]; then # sentinel process <file_to_process>
                _filedir "$cur" # Pass current word for partial path completion
                return 0
            fi
            # For subsequent arguments (options like --mode), argcomplete should take over.
            COMPREPLY=()
            return 0
            ;;
        help)
            # 'help' subcommand might take another subcommand name as argument
            if [[ "$cword" -eq 2 ]]; then # sentinel help <subcommand_to_get_help_for>
                 COMPREPLY=( $(compgen -W "$(echo $subcommands | sed 's/help//')" -- "$cur") ) # list subcommands, excluding 'help' itself
            else
                COMPREPLY=()
            fi
            ;;
        *)
            # This case handles when words[1] is a global option like --verbose or --config
            # If words[1] was --config, it's handled above. If it's --verbose, no further args.
            # If it's an unknown command, complete with subcommands (already handled by cword -le 1 check).
            COMPREPLY=()
            ;;
    esac

    return 0
}

# Register the completion function for the 'sentinel' command.
complete -o bashdefault -o default -F _sentinel_completions sentinel
