#!/usr/bin/env bash
# ~/bashrc.postcustom
#
# This file is included very last after running bashrc.
# You can use this to change things like environment variables set
# without needing to edit the distributed version

export LANG=en_US.utf8
export LC_ALL=en_US.utf8

#========================================================================
#========================================================================
# Module System Behavior - Global Settings
#----------------------------------------
# These settings control how the module system operates

# Module Security Configuration
# ----------------------------
# These settings control module security verification

# Configuration Caching System
# ------------------------
# Controls how configuration files are cached for faster shell startup
export SENTINEL_CONFIG_CACHE_ENABLED=1
export SENTINEL_CONFIG_FORCE_REFRESH=0
export SENTINEL_CONFIG_CACHE_RETENTION_DAYS=30
export SENTINEL_CONFIG_VERIFY_HASH=1

# Module System Optimization
# -------------------------
# Controls module dependency resolution and loading behavior
export SENTINEL_MODULE_DEBUG=0
export SENTINEL_MODULE_AUTOLOAD=1
export SENTINEL_MODULE_CACHE_ENABLED=1
export SENTINEL_MODULE_VERIFY=1


#========================================================================
# MODULE-SPECIFIC CONFIGURATIONS
#========================================================================

# SENTINEL Feature Module Toggles
# -------------------------------
# Uncomment to enable/disable specific SENTINEL feature modules:
export SENTINEL_OBFUSCATE_ENABLED=1
export SENTINEL_FZF_ENABLED=1
export SENTINEL_ML_ENABLED=1
export SENTINEL_OSINT_ENABLED=1
export SENTINEL_CYBERSEC_ENABLED=1
export SENTINEL_GITSTAR_ENABLED=1
export SENTINEL_CHAT_ENABLED=1
export SENTINEL_SMALLLLM_ENABLED=1


# Obfuscation Module
# ------------------
export OBFUSCATE_OUTPUT_DIR="${HOME}/secure/obfuscated_files"
# Optional: set a custom temp directory for obfuscation
# export OBFUSCATE_TEMP_DIR="/tmp/obfuscate_temp"

# Hashcat Configuration
# --------------------
export HASHCAT_BIN="/usr/bin/hashcat"
export HASHCAT_WORDLISTS_DIR="/usr/share/wordlists"
export HASHCAT_OUTPUT_DIR="${HOME}/.hashcat/cracked"

# Distcc Configuration
# -------------------
export DISTCC_HOSTS="localhost"       # Space-separated list of compilation hosts
export CCACHE_SIZE="5G"               # Maximum size of ccache

#========================================================================
# CUSTOM PROMPT CONFIGURATION (OPTIONAL)
#========================================================================
# Uncomment to override the default prompt
# export PS1=

#========================================================================
# USER CUSTOMIZATIONS
#========================================================================
# Add your custom configurations, aliases, and functions below

# Source centralized configuration

# Don't re-source bash_modules if already loaded (prevents infinite loops)
if [[ -z "${_SENTINEL_MODULES_LOADED}" ]]; then
    # Source the main bash_modules first to get core functions
    if [[ -f "/opt/github/SENTINEL/bash_modules" ]]; then
        export SENTINEL_SKIP_AUTO_LOAD=1  # Prevent duplicate loading
        source "/opt/github/SENTINEL/bash_modules"
    fi
fi

# Source module manager and parallel loader only if not already loaded
if [[ -z "${_SENTINEL_MODULE_MANAGER_LOADED}" ]] && [[ -f "/opt/github/SENTINEL/bash_modules.d/module_manager.module" ]]; then
    source "/opt/github/SENTINEL/bash_modules.d/module_manager.module"
fi
if [[ -z "${_SENTINEL_PARALLEL_LOADER_LOADED}" ]] && [[ -f "/opt/github/SENTINEL/bash_modules.d/parallel_loader.module" ]]; then
    source "/opt/github/SENTINEL/bash_modules.d/parallel_loader.module"
fi

# Load all enabled modules in parallel only if function exists and modules not already loaded
if type parallel_load_modules &>/dev/null && [[ -z "${_SENTINEL_PARALLEL_MODULES_LOADED}" ]]; then
    export _SENTINEL_PARALLEL_MODULES_LOADED=1
    parallel_load_modules "${HOME}/.bash_modules"
fi

# ========================================================================
# Performance Configuration
# ========================================================================
# heavy components. This can significantly reduce shell startup time.
#
# By default, lazy loading is enabled (CONFIG[LAZY_LOAD]=1)
# You can disable it by uncommenting the following line:
# export U_LAZY_LOAD=0
#
# Development environments that are lazy loaded:
# - Pyenv (Python version management)
# - NVM (Node.js version management)
# - RVM (Ruby version management)
# - Cargo (Rust tools)
#
# To lazy load additional tools, use the lazy_load function:
# lazy_load <command> <load_function>
#
# Example:
# function __load_custom_tool() {
#     source /path/to/custom/tool/setup.sh
# }
# lazy_load custom_tool __load_custom_tool
#
# See bash_functions for more predefined loader functions
# ========================================================================

export U_LAZY_LOAD=1

# Lazy loading for development tools
if [[ -n "${CONFIG[LAZY_LOAD]+set}" && "${CONFIG[LAZY_LOAD]}" == "1" ]] || [[ "${U_LAZY_LOAD:-1}" == "1" ]]; then
    function pyenv() {
        { unset -f pyenv; } 2>/dev/null || true
        if [[ -d "$HOME/.pyenv" ]]; then
            { export PYENV_ROOT="$HOME/.pyenv"; } 2>/dev/null || true
            { export PATH="$PYENV_ROOT/bin:$PATH"; } 2>/dev/null || true
            { eval "$(command pyenv init - 2>/dev/null)"; } 2>/dev/null || true
            { eval "$(command pyenv virtualenv-init - 2>/dev/null)"; } 2>/dev/null || true
            { pyenv "$@"; } 2>/dev/null || return 0
        else
            { echo "pyenv is not installed"; } 2>/dev/null || true
            return 0
        fi
    }
    function nvm() {
        { unset -f nvm; } 2>/dev/null || true
        if [[ -d "$HOME/.nvm" ]]; then
            { export NVM_DIR="$HOME/.nvm"; } 2>/dev/null || true
            { [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"; } 2>/dev/null || true
            { [ -s "$NVM_DIR/bash_completion" ] && . "$NVM_DIR/bash_completion"; } 2>/dev/null || true
            { nvm "$@"; } 2>/dev/null || return 0
        else
            { echo "nvm is not installed"; } 2>/dev/null || true
            return 0
        fi
    }
    function node() {
        { unset -f node; } 2>/dev/null || true
        { nvm >/dev/null 2>&1; } 2>/dev/null || true
        { node "$@"; } 2>/dev/null || return 0
    }
    function npm() {
        { unset -f npm; } 2>/dev/null || true
        { nvm >/dev/null 2>&1; } 2>/dev/null || true
        { npm "$@"; } 2>/dev/null || return 0
    }
    function python() {
        { unset -f python; } 2>/dev/null || true
        { pyenv >/dev/null 2>&1; } 2>/dev/null || true
        { python "$@"; } 2>/dev/null || return 0
    }
    function pip() {
        { unset -f pip; } 2>/dev/null || true
        { pyenv >/dev/null 2>&1; } 2>/dev/null || true
        { pip "$@"; } 2>/dev/null || return 0
    }
fi


# Add your customizations below this line

# Silence module status messages
export SENTINEL_QUIET_STATUS=1
export SENTINEL_VERBOSE=0
export SENTINEL_DEBUG=0
export SENTINEL_DEBUG_MODULES=0
export SENTINEL_QUIET_MODE=1
export SENTINEL_DISABLE_STARTUP_MESSAGES=1
export SENTINEL_SUPPRESS_MODULE_MESSAGES=1

# Create function to show critical startup info only
sentinel_startup_summary() {
    if [[ "${SENTINEL_QUIET_MODE:-0}" == "1" ]]; then
        return 0
    fi
    
    echo -e "\033[32m[SENTINEL]\033[0m Ready - $(date +'%H:%M:%S')"
    
    # Show only critical status
    local critical_info=""
    
    # Check if in data science environment
    if [[ -n "${VIRTUAL_ENV}" && "${VIRTUAL_ENV}" == "${HOME}/datascience/envs/dsenv" ]]; then
        critical_info+=" | dsenv active"
    fi
    
    # Check NPU status briefly
    if [[ -e /dev/accel/accel0 ]]; then
        critical_info+=" | NPU: available"
    fi
    
    # Show module count
    local module_count=$(echo "${!SENTINEL_LOADED_MODULES[@]}" | wc -w 2>/dev/null || echo "0")
    critical_info+=" | ${module_count} modules"
    
    if [[ -n "$critical_info" ]]; then
        echo -e "\033[32m[SENTINEL]\033[0m${critical_info}"
    fi
}

# OpenVINO Check (after Python venv setup)
DSENV_PATH="${HOME}/datascience/envs/dsenv"
SENTINEL_VENV_PATH="${HOME}/venv"

# OpenVINO Check (only show warnings/errors, not success messages)
if [[ "${SENTINEL_QUIET_MODE:-0}" != "1" ]]; then
    if [[ -n "${VIRTUAL_ENV}" && "${VIRTUAL_ENV}" == "${DSENV_PATH}" ]]; then
        # dsenv is active - only warn if OpenVINO not found
        if ! python -c "import openvino" >/dev/null 2>&1; then
            echo "[SENTINEL] Warning: dsenv active but OpenVINO Python package not found."
        fi
    elif [[ -n "${VIRTUAL_ENV}" && "${VIRTUAL_ENV}" == "${SENTINEL_VENV_PATH}" ]]; then
        # SENTINEL venv - expected that OpenVINO won't be available
        if ! "${SENTINEL_VENV_PATH}/bin/python" -c "import openvino" >/dev/null 2>&1; then
            echo "[SENTINEL] SENTINEL venv active. For OpenVINO, activate dsenv: source ${DSENV_PATH}/bin/activate"
        fi
    elif [[ -z "${VIRTUAL_ENV}" ]]; then
        echo "[SENTINEL] No virtual environment active. Activate dsenv for OpenVINO: source ${DSENV_PATH}/bin/activate"
    fi
fi

# Python virtual environment management
mkvenv() {
    local venv_dir=".venv"
    local python_cmd="python3"
    local requirements_file="requirements.txt"

    # Handle optional arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -d|--dir)
                venv_dir="$2"
                shift 2
                ;;
            -p|--python)
                python_cmd="$2"
                shift 2
                ;;
            -r|--requirements)
                requirements_file="$2"
                shift 2
                ;;
            -h|--help)
                echo "Usage: mkvenv [OPTIONS]"
                echo "Create and activate a Python virtual environment in the current directory."
                echo ""
                echo "Options:"
                echo "  -d, --dir DIR           Specify the virtual environment directory (default: .venv)"
                echo "  -p, --python PYTHON     Specify the Python executable to use (default: python3)"
                echo "  -r, --requirements FILE Install packages from requirements file after creation"
                echo "  -h, --help              Show this help message and exit"
                return 0
                ;;
            *)
                echo "Unknown option: $1"
                echo "Use mkvenv --help for usage information."
                return 1
                ;;
        esac
    done

    # Check if Python is available
    if ! command -v "$python_cmd" &>/dev/null; then
        echo "[✗] Error: $python_cmd not found"
        return 1
    fi

    # Create the virtual environment if it doesn't exist
    if [[ ! -d "$venv_dir" ]]; then
        echo "[+] Creating virtual environment in: $venv_dir"
        "$python_cmd" -m venv "$venv_dir"
        if [[ $? -ne 0 ]]; then
            echo "[✗] Failed to create virtual environment"
        fi
    fi
}


# =============================
# End of bashrc.postcustom
# =============================
