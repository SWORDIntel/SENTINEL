#!/usr/bin/env bash
# SENTINEL Module System
# Provides dynamic loading and management of bashrc extensions

# Module directory path
export SENTINEL_MODULES_PATH=${U_MODULES_PATH:-"$HOME/.bash_modules.d"}

# Registry of loaded modules
declare -A SENTINEL_LOADED_MODULES

# Set quiet mode by default (set to 0 for verbose output)
export SENTINEL_QUIET_MODULES=${SENTINEL_QUIET_MODULES:-1}

# Initialize modules directory if it doesn't exist
if [[ ! -d "$SENTINEL_MODULES_PATH" ]]; then
    mkdir -p "$SENTINEL_MODULES_PATH"
fi

# Check if list of modules file exists
if [[ ! -f "$HOME/.bash_modules" ]]; then
    touch "$HOME/.bash_modules"
fi

# Output functions with verbosity control
emsg() {
    [[ "$SENTINEL_QUIET_MODULES" != "1" ]] && echo "$@"
}

ewarn() {
    # Always show warnings
    echo "$@"
}

eerror() {
    # Always show errors
    echo "$@" >&2
}

# Module loading function with error handling and dependency resolution
module_enable() {
    local module_name="$1"
    local force="${2:-0}"
    local called_by="${3:-direct}"
    local module_file=""
    
    # Check for both .sh and .module extensions
    if [[ -f "$SENTINEL_MODULES_PATH/$module_name.sh" ]]; then
        module_file="$SENTINEL_MODULES_PATH/$module_name.sh"
    elif [[ -f "$SENTINEL_MODULES_PATH/$module_name.module" ]]; then
        module_file="$SENTINEL_MODULES_PATH/$module_name.module"
    fi
    
    # Check if module is already loaded
    if [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "1" ]] && [[ "$force" != "1" ]]; then
        [[ "$called_by" == "direct" && "$SENTINEL_QUIET_MODULES" != "1" ]] && emsg "Module '$module_name' is already loaded."
        return 0
    fi
    
    # Check if module file exists
    if [[ -z "$module_file" || ! -f "$module_file" ]]; then
        if [[ "$called_by" == "direct" ]]; then
            eerror "Module '$module_name' not found."
            
            # Check for similar modules as suggestion
            local suggestions=$(find "$SENTINEL_MODULES_PATH" -name "*.sh" -o -name "*.module" | xargs -n1 basename | sed 's/\.sh$//' | sed 's/\.module$//' | grep -i "$module_name" || echo "")
            if [[ -n "$suggestions" ]]; then
                echo "Did you mean one of these?"
                echo "$suggestions" | while IFS= read -r suggestion; do
                    echo "  $suggestion"
                done
            fi
        fi
        return 1
    fi
    
    # Load module source to extract metadata without executing
    local dependencies=""
    if grep -q "SENTINEL_MODULE_DEPENDENCIES=" "$module_file"; then
        dependencies=$(grep "SENTINEL_MODULE_DEPENDENCIES=" "$module_file" | head -n1 | cut -d'"' -f2)
    fi
    
    # Process dependencies if any
    if [[ -n "$dependencies" ]]; then
        for dep in $dependencies; do
            if [[ "${SENTINEL_LOADED_MODULES[$dep]}" != "1" ]]; then
                emsg "Resolving dependency: $dep for $module_name"
                module_enable "$dep" "$force" "$module_name"
                
                # If dependency loading failed, abort
                if [[ $? -ne 0 ]]; then
                    eerror "Failed to load dependency '$dep' required by '$module_name'"
                    return 1
                fi
            fi
        done
    fi
    
    # Actually load the module
    if [[ -x "$module_file" || "$force" == "1" ]]; then
        # Mark as loading to detect circular dependencies
        SENTINEL_LOADED_MODULES["$module_name"]="loading"
        
        # Source the module
        if source "$module_file"; then
            SENTINEL_LOADED_MODULES["$module_name"]="1"
            
            # Add to enabled modules list if it's not already there
            if ! grep -q "^${module_name}\$" "$HOME/.bash_modules" && [[ "$called_by" == "direct" ]]; then
                echo "$module_name" >> "$HOME/.bash_modules"
                emsg "Module '$module_name' enabled and will be loaded on startup."
            fi
            
            # Only show success message if direct call and not in quiet mode
            [[ "$called_by" == "direct" && "$SENTINEL_QUIET_MODULES" != "1" ]] && emsg "Module '$module_name' loaded successfully."
            return 0
        else
            SENTINEL_LOADED_MODULES["$module_name"]="failed"
            eerror "Failed to load module '$module_name' - error in module code."
            return 1
        fi
    else
        eerror "Module file '$module_file' is not executable. Run: chmod +x '$module_file'"
        return 1
    fi
}

# Disable a module
module_disable() {
    local module_name="$1"
    
    # Check if module is in the enabled list
    if grep -q "^${module_name}\$" "$HOME/.bash_modules"; then
        # Remove from enabled list
        sed -i "/^${module_name}\$/d" "$HOME/.bash_modules"
        
        # If module is loaded in current session, mark it as unloaded
        # (can't actually unload it without starting a new session)
        if [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "1" ]]; then
            unset "SENTINEL_LOADED_MODULES[$module_name]"
            emsg "Module '$module_name' disabled. It will not be loaded in future sessions."
            emsg "Note: The module remains active in the current session."
        else
            emsg "Module '$module_name' disabled. It will not be loaded in future sessions."
        fi
        return 0
    else
        ewarn "Module '$module_name' is not enabled."
        return 1
    fi
}

# List all modules with their status
module_list() {
    echo "SENTINEL Modules"
    echo "================"
    
    # Count the modules
    local total_modules=0
    local enabled_modules=0
    local loaded_modules=0
    
    # Get list of module files (both .sh and .module)
    local module_files=$(find "$SENTINEL_MODULES_PATH" -name "*.sh" -o -name "*.module" | sort)
    
    echo -e "\nAvailable modules:"
    echo "-----------------"
    
    # Process each module
    while IFS= read -r module_file; do
        [[ -z "$module_file" ]] && continue
        
        # Extract module name without extension (both .sh and .module)
        local module_name=$(basename "$module_file" | sed 's/\.sh$//' | sed 's/\.module$//')
        total_modules=$((total_modules + 1))
        
        # Get module description
        local description=""
        if grep -q "SENTINEL_MODULE_DESCRIPTION=" "$module_file"; then
            description=$(grep "SENTINEL_MODULE_DESCRIPTION=" "$module_file" | head -n1 | cut -d'"' -f2)
        else
            # Try to extract from header comment
            description=$(grep -A1 "# SENTINEL Module:" "$module_file" | tail -n1 | sed 's/# //')
            [[ "$description" == *"SENTINEL Module:"* ]] && description=""
        fi
        
        # Determine module status
        local status=" "
        local status_color="${NC}"
        
        # Check if enabled at startup
        if grep -q "^${module_name}\$" "$HOME/.bash_modules"; then
            status="E"
            status_color="${GREEN}"
            enabled_modules=$((enabled_modules + 1))
        fi
        
        # Check if currently loaded
        if [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "1" ]]; then
            status="${status}L"
            status_color="${GREEN}"
            loaded_modules=$((loaded_modules + 1))
        elif [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "failed" ]]; then
            status="${status}F"
            status_color="${RED}"
        fi
        
        # Format status indicator
        if [[ "$status" == " " ]]; then
            status="  "
        else
            status="[${status}]"
        fi
        
        # Display module info
        echo -e "${status_color}${status}${NC} ${module_name}\t${description:0:50}${description:50:+...}"
    done <<< "$module_files"
    
    echo -e "\nStatus: [E]=Enabled at startup, [L]=Loaded in current session, [F]=Failed to load"
    echo -e "Summary: $total_modules total, $enabled_modules enabled, $loaded_modules loaded"
}

# Function to control verbosity
module_verbose() {
    if [[ "$1" == "on" ]]; then
        export SENTINEL_QUIET_MODULES=0
        echo "Module verbose mode ON"
    elif [[ "$1" == "off" ]]; then
        export SENTINEL_QUIET_MODULES=1
        echo "Module verbose mode OFF"
    else
        echo "Current module verbose mode: $([[ "$SENTINEL_QUIET_MODULES" == "1" ]] && echo "OFF" || echo "ON")"
        echo "Usage: module_verbose [on|off]"
    fi
}

# Load all enabled modules on startup with minimal output
_load_enabled_modules() {
    if [[ -f "$HOME/.bash_modules" ]]; then
        # Only show this message in verbose mode
        [[ "$SENTINEL_QUIET_MODULES" != "1" ]] && echo "Loading modules from $HOME/.bash_modules..."
        
        # Count for summary
        local enabled_count=0
        local success_count=0
        
        while IFS= read -r module; do
            [[ -z "$module" || "$module" =~ ^# ]] && continue
            enabled_count=$((enabled_count + 1))
            module_enable "$module" "0" "startup"
            [[ $? -eq 0 ]] && success_count=$((success_count + 1))
        done < "$HOME/.bash_modules"
        
        # Show summary only in verbose mode
        [[ "$SENTINEL_QUIET_MODULES" != "1" ]] && echo "Loaded $success_count/$enabled_count modules"
    fi
    
    # Also load our new GitHub Star Analyzer module
    if [[ -f "$SENTINEL_MODULES_PATH/sentinel_gitstar.module" ]]; then
        module_enable "sentinel_gitstar" "0" "startup"
    fi
}

# Register backwards compatibility functions
bash_module() {
    ewarn "Using legacy function bash_module(). Consider switching to module_enable()."
    module_enable "$1"
}

bash_list_modules() {
    ewarn "Using legacy function bash_list_modules(). Consider switching to module_list()."
    module_list
}

# Load modules on startup
_load_enabled_modules

# Load modules
for f in ./bash_modules.d/*.module; do
  [ -r "$f" ] && source "$f"
done

# Additional modules can be loaded here
# For example:
# source /path/to/custom/module.sh

# Add our GitHub Star Analyzer module
if [ -r "./bash_modules.d/sentinel_gitstar.module" ]; then
  source "./bash_modules.d/sentinel_gitstar.module"
fi