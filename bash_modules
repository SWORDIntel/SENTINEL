#!/usr/bin/env bash
# SENTINEL Module System
# Provides dynamic loading and management of bashrc extensions

# Module directory path
export SENTINEL_MODULES_PATH=${U_MODULES_PATH:-"$HOME/.bash_modules.d"}

# Registry of loaded modules
declare -A SENTINEL_LOADED_MODULES

# Initialize modules directory if it doesn't exist
if [[ ! -d "$SENTINEL_MODULES_PATH" ]]; then
    mkdir -p "$SENTINEL_MODULES_PATH"
fi

# Check if list of modules file exists
if [[ ! -f "$HOME/.bash_modules" ]]; then
    touch "$HOME/.bash_modules"
fi

# Module loading function with error handling and dependency resolution
module_enable() {
    local module_name="$1"
    local force="${2:-0}"
    local called_by="${3:-direct}"
    local module_file="$SENTINEL_MODULES_PATH/$module_name.sh"
    
    # Check if module is already loaded
    if [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "1" ]] && [[ "$force" != "1" ]]; then
        [[ "$called_by" == "direct" ]] && emsg "Module '$module_name' is already loaded."
        return 0
    fi
    
    # Check if module file exists
    if [[ ! -f "$module_file" ]]; then
        if [[ "$called_by" == "direct" ]]; then
            eerror "Module '$module_name' not found at $module_file"
            
            # Check for similar modules as suggestion
            local suggestions=$(find "$SENTINEL_MODULES_PATH" -name "*.sh" -exec basename {} .sh \; | grep -i "$module_name" || echo "")
            if [[ -n "$suggestions" ]]; then
                echo "Did you mean one of these?"
                echo "$suggestions" | while IFS= read -r suggestion; do
                    echo "  $suggestion"
                done
            fi
        fi
        return 1
    fi
    
    # Load module source to extract metadata without executing
    local dependencies=""
    if grep -q "SENTINEL_MODULE_DEPENDENCIES=" "$module_file"; then
        dependencies=$(grep "SENTINEL_MODULE_DEPENDENCIES=" "$module_file" | head -n1 | cut -d'"' -f2)
    fi
    
    # Process dependencies if any
    if [[ -n "$dependencies" ]]; then
        for dep in $dependencies; do
            if [[ "${SENTINEL_LOADED_MODULES[$dep]}" != "1" ]]; then
                emsg "Resolving dependency: $dep for $module_name"
                module_enable "$dep" "$force" "$module_name"
                
                # If dependency loading failed, abort
                if [[ $? -ne 0 ]]; then
                    eerror "Failed to load dependency '$dep' required by '$module_name'"
                    return 1
                fi
            fi
        done
    fi
    
    # Actually load the module
    if [[ -x "$module_file" || "$force" == "1" ]]; then
        # Mark as loading to detect circular dependencies
        SENTINEL_LOADED_MODULES["$module_name"]="loading"
        
        # Source the module
        if source "$module_file"; then
            SENTINEL_LOADED_MODULES["$module_name"]="1"
            
            # Add to enabled modules list if it's not already there
            if ! grep -q "^${module_name}\$" "$HOME/.bash_modules" && [[ "$called_by" == "direct" ]]; then
                echo "$module_name" >> "$HOME/.bash_modules"
                emsg "Module '$module_name' enabled and will be loaded on startup."
            fi
            
            [[ "$called_by" == "direct" ]] && emsg "Module '$module_name' loaded successfully."
            return 0
        else
            SENTINEL_LOADED_MODULES["$module_name"]="failed"
            eerror "Failed to load module '$module_name' - error in module code."
            return 1
        fi
    else
        eerror "Module file '$module_file' is not executable. Run: chmod +x '$module_file'"
        return 1
    fi
}

# Disable a module
module_disable() {
    local module_name="$1"
    
    # Check if module is in the enabled list
    if grep -q "^${module_name}\$" "$HOME/.bash_modules"; then
        # Remove from enabled list
        sed -i "/^${module_name}\$/d" "$HOME/.bash_modules"
        
        # If module is loaded in current session, mark it as unloaded
        # (can't actually unload it without starting a new session)
        if [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "1" ]]; then
            unset "SENTINEL_LOADED_MODULES[$module_name]"
            emsg "Module '$module_name' disabled. It will not be loaded in future sessions."
            emsg "Note: The module remains active in the current session."
        else
            emsg "Module '$module_name' disabled. It will not be loaded in future sessions."
        fi
        return 0
    else
        ewarn "Module '$module_name' is not enabled."
        return 1
    fi
}

# List all modules with their status
module_list() {
    echo "SENTINEL Modules"
    echo "================"
    
    # Count the modules
    local total_modules=0
    local enabled_modules=0
    local loaded_modules=0
    
    # Get list of module files
    local module_files=$(find "$SENTINEL_MODULES_PATH" -name "*.sh" -type f | sort)
    
    echo -e "\nAvailable modules:"
    echo "-----------------"
    
    # Process each module
    while IFS= read -r module_file; do
        [[ -z "$module_file" ]] && continue
        
        local module_name=$(basename "$module_file" .sh)
        total_modules=$((total_modules + 1))
        
        # Get module description
        local description=""
        if grep -q "SENTINEL_MODULE_DESCRIPTION=" "$module_file"; then
            description=$(grep "SENTINEL_MODULE_DESCRIPTION=" "$module_file" | head -n1 | cut -d'"' -f2)
        else
            # Try to extract from header comment
            description=$(grep -A1 "# SENTINEL Module:" "$module_file" | tail -n1 | sed 's/# //')
            [[ "$description" == *"SENTINEL Module:"* ]] && description=""
        fi
        
        # Determine module status
        local status=" "
        local status_color="${NC}"
        
        # Check if enabled at startup
        if grep -q "^${module_name}\$" "$HOME/.bash_modules"; then
            status="E"
            status_color="${GREEN}"
            enabled_modules=$((enabled_modules + 1))
        fi
        
        # Check if currently loaded
        if [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "1" ]]; then
            status="${status}L"
            status_color="${GREEN}"
            loaded_modules=$((loaded_modules + 1))
        elif [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "failed" ]]; then
            status="${status}F"
            status_color="${RED}"
        fi
        
        # Format status indicator
        if [[ "$status" == " " ]]; then
            status="  "
        else
            status="[${status}]"
        fi
        
        # Display module info
        echo -e "${status_color}${status}${NC} ${module_name}\t${description:0:50}${description:50:+...}"
    done <<< "$module_files"
    
    echo -e "\nStatus: [E]=Enabled at startup, [L]=Loaded in current session, [F]=Failed to load"
    echo -e "Summary: $total_modules total, $enabled_modules enabled, $loaded_modules loaded"
}

# Get detailed information about a module
module_info() {
    local module_name="$1"
    local module_file="$SENTINEL_MODULES_PATH/$module_name.sh"
    
    if [[ ! -f "$module_file" ]]; then
        eerror "Module '$module_name' not found."
        return 1
    fi
    
    echo "Module Information: $module_name"
    echo "=================================="
    
    # Extract metadata
    local version=$(grep "SENTINEL_MODULE_VERSION=" "$module_file" | head -n1 | cut -d'"' -f2)
    local description=$(grep "SENTINEL_MODULE_DESCRIPTION=" "$module_file" | head -n1 | cut -d'"' -f2)
    local author=$(grep "SENTINEL_MODULE_AUTHOR=" "$module_file" | head -n1 | cut -d'"' -f2)
    local dependencies=$(grep "SENTINEL_MODULE_DEPENDENCIES=" "$module_file" | head -n1 | cut -d'"' -f2)
    
    # Display metadata
    echo -e "Version:\t${version:-unknown}"
    echo -e "Author:\t\t${author:-unknown}"
    echo -e "Description:\t${description:-No description available}"
    echo -e "Dependencies:\t${dependencies:-none}"
    
    # Status information
    echo -e "\nStatus:"
    if grep -q "^${module_name}\$" "$HOME/.bash_modules"; then
        echo -e "  ${GREEN}✓${NC} Enabled at startup"
    else
        echo -e "  ${RED}✗${NC} Not enabled at startup"
    fi
    
    if [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "1" ]]; then
        echo -e "  ${GREEN}✓${NC} Loaded in current session"
    elif [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "failed" ]]; then
        echo -e "  ${RED}✗${NC} Failed to load in current session"
    else
        echo -e "  ${RED}✗${NC} Not loaded in current session"
    fi
    
    # Show brief breakdown of functions provided by this module
    echo -e "\nFunctions provided:"
    if [[ -x "$module_file" ]]; then
        # Extract function declarations
        grep -E "^function [a-zA-Z0-9_-]+\(\)|^[a-zA-Z0-9_-]+\(\)" "$module_file" | 
        sed -E 's/function ([a-zA-Z0-9_-]+)\(\)|\s*\{$|\s*\{|\(\)|\s*$/\1/g' | 
        while IFS= read -r func; do
            [[ -z "$func" ]] && continue
            echo -e "  - $func"
        done
    else
        echo -e "  (Cannot analyze: Module file is not executable)"
    fi
}

# Helper to create a new module
module_create() {
    local module_name="$1"
    local module_file="$SENTINEL_MODULES_PATH/$module_name.sh"
    
    if [[ -z "$module_name" ]]; then
        eerror "Module name is required."
        echo "Usage: module_create <module_name>"
        return 1
    fi
    
    # Check if module already exists
    if [[ -f "$module_file" ]]; then
        eerror "Module '$module_name' already exists at $module_file"
        return 1
    fi
    
    # Create module file with template content
    # (Template content would go here in a real implementation)
    
    # Make it executable
    chmod +x "$module_file"
    
    emsg "Module '$module_name' created at $module_file"
    emsg "Edit the file to implement your module functionality."
    emsg "To enable the module, run: module_enable $module_name"
}

# Load all enabled modules on startup
_load_enabled_modules() {
    if [[ -f "$HOME/.bash_modules" ]]; then
        emsg "Loading modules from $HOME/.bash_modules..."
        while IFS= read -r module; do
            [[ -z "$module" || "$module" =~ ^# ]] && continue
            module_enable "$module" "0" "startup"
        done < "$HOME/.bash_modules"
    fi
}

# Register backwards compatibility functions
bash_module() {
    ewarn "Using legacy function bash_module(). Consider switching to module_enable()."
    module_enable "$1"
}

bash_list_modules() {
    ewarn "Using legacy function bash_list_modules(). Consider switching to module_list()."
    module_list
}

# Load modules on startup
_load_enabled_modules