#!/usr/bin/env bash
# SENTINEL Module System
# Provides dynamic loading and management of bashrc extensions,
# with auto-population and auto-loading support for module files.

# Module directory path (default or can be overridden via U_MODULES_PATH)
export SENTINEL_MODULES_PATH=${U_MODULES_PATH:-"$HOME/.bash_modules.d"}

# Registry of loaded modules using an associative array
declare -A SENTINEL_LOADED_MODULES

# Initialize the modules directory if it doesn't exist
if [[ ! -d "$SENTINEL_MODULES_PATH" ]]; then
    mkdir -p "$SENTINEL_MODULES_PATH"
fi

# Check if the modules list file exists; if not, create it
if [[ ! -f "$HOME/.bash_modules" ]]; then
    touch "$HOME/.bash_modules"
fi

# --- Module Management Functions ---

# Enable (load) a module with dependency resolution and error handling.
module_enable() {
    local module_name="$1"
    local force="${2:-0}"
    local called_by="${3:-direct}"
    # By default, modules are assumed to be stored with a .module extension.
    local module_file="$SENTINEL_MODULES_PATH/$module_name.module"

    # Check if module is already loaded.
    if [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "1" ]] && [[ "$force" != "1" ]]; then
        [[ "$called_by" == "direct" ]] && echo "Module '$module_name' is already loaded."
        return 0
    fi

    # Check if module file exists.
    if [[ ! -f "$module_file" ]]; then
        if [[ "$called_by" == "direct" ]]; then
            echo "Error: Module '$module_name' not found at $module_file" 1>&2

            # Suggest similar module names.
            local suggestions
            suggestions=$(find "$SENTINEL_MODULES_PATH" -name "*.module" -exec basename {} .module \; | grep -i "$module_name" || echo "")
            if [[ -n "$suggestions" ]]; then
                echo "Did you mean one of these?" 1>&2
                echo "$suggestions" | while IFS= read -r suggestion; do
                    echo "  $suggestion" 1>&2
                done
            fi
        fi
        return 1
    fi

    # Load module source to extract metadata if available.
    local dependencies=""
    if grep -q "SENTINEL_MODULE_DEPENDENCIES=" "$module_file"; then
        dependencies=$(grep "SENTINEL_MODULE_DEPENDENCIES=" "$module_file" | head -n1 | cut -d'"' -f2)
    fi

    # Process dependencies if any.
    if [[ -n "$dependencies" ]]; then
        for dep in $dependencies; do
            if [[ "${SENTINEL_LOADED_MODULES[$dep]}" != "1" ]]; then
                echo "Resolving dependency: $dep for $module_name" 1>&2
                module_enable "$dep" "$force" "$module_name"
                if [[ $? -ne 0 ]]; then
                    echo "Error: Failed to load dependency '$dep' required by '$module_name'" 1>&2
                    return 1
                fi
            fi
        done
    fi

    # Actually load the module.
    if [[ -x "$module_file" || "$force" == "1" ]]; then
        # Mark as loading to detect circular dependencies.
        SENTINEL_LOADED_MODULES["$module_name"]="loading"
        # Source the module.
        if source "$module_file"; then
            SENTINEL_LOADED_MODULES["$module_name"]="1"
            # Add to the enabled modules list if not already there.
            if ! grep -q "^${module_name}\$" "$HOME/.bash_modules" && [[ "$called_by" == "direct" ]]; then
                echo "$module_name" >> "$HOME/.bash_modules"
                echo "Module '$module_name' enabled and will be loaded on startup." 1>&2
            fi
            [[ "$called_by" == "direct" ]] && echo "Module '$module_name' loaded successfully." 1>&2
            return 0
        else
            SENTINEL_LOADED_MODULES["$module_name"]="failed"
            echo "Error: Failed to load module '$module_name' â€“ error in module code." 1>&2
            return 1
        fi
    else
        echo "Error: Module file '$module_file' is not executable. Run: chmod +x '$module_file'" 1>&2
        return 1
    fi
}

# Disable a module (removes it from the enabled list, note that unloading it from the current session is not possible)
module_disable() {
    local module_name="$1"
    
    if grep -q "^${module_name}\$" "$HOME/.bash_modules"; then
        # Remove from the enabled list.
        sed -i "/^${module_name}\$/d" "$HOME/.bash_modules"
        # Unset if it is loaded in the current session.
        if [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "1" ]]; then
            unset "SENTINEL_LOADED_MODULES[$module_name]"
            echo "Module '$module_name' disabled. It will not be loaded in future sessions." 1>&2
            echo "Note: The module remains active in the current session." 1>&2
        else
            echo "Module '$module_name' disabled. It will not be loaded in future sessions." 1>&2
        fi
        return 0
    else
        echo "Warning: Module '$module_name' is not enabled." 1>&2
        return 1
    fi
}

# List all modules with their status.
module_list() {
    echo "SENTINEL Modules"
    echo "================"

    local total_modules=0
    local enabled_modules=0
    local loaded_modules=0

    # Get list of module files matching .module extension.
    local module_files
    module_files=$(find "$SENTINEL_MODULES_PATH" -name "*.module" -type f | sort)
    
    echo -e "\nAvailable modules:"
    echo "-----------------"

    while IFS= read -r module_file; do
        [[ -z "$module_file" ]] && continue

        local module_name
        module_name=$(basename "$module_file" .module)
        total_modules=$((total_modules + 1))
        
        local description=""
        if grep -q "SENTINEL_MODULE_DESCRIPTION=" "$module_file"; then
            description=$(grep "SENTINEL_MODULE_DESCRIPTION=" "$module_file" | head -n1 | cut -d'"' -f2)
        else
            description=$(grep -A1 "# SENTINEL Module:" "$module_file" | tail -n1 | sed 's/# //')
            [[ "$description" == *"SENTINEL Module:"* ]] && description=""
        fi
        
        local status=" "
        # Check if enabled at startup.
        if grep -q "^${module_name}\$" "$HOME/.bash_modules"; then
            status="E"
            enabled_modules=$((enabled_modules + 1))
        fi

        # Check if currently loaded.
        if [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "1" ]]; then
            status="${status}L"
            loaded_modules=$((loaded_modules + 1))
        elif [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "failed" ]]; then
            status="${status}F"
        fi

        if [[ "$status" == " " ]]; then
            status="  "
        else
            status="[$status]"
        fi

        # Display module info.
        printf "%-8s %-20s %s\n" "$status" "$module_name" "${description}"
    done <<< "$module_files"

    echo -e "\nStatus: [E]=Enabled at startup, [L]=Loaded in current session, [F]=Failed to load"
    echo "Summary: $total_modules total, $enabled_modules enabled, $loaded_modules loaded"
}

# Get detailed information about a module.
module_info() {
    local module_name="$1"
    local module_file="$SENTINEL_MODULES_PATH/$module_name.module"
    
    if [[ ! -f "$module_file" ]]; then
        echo "Error: Module '$module_name' not found." 1>&2
        return 1
    fi
    
    echo "Module Information: $module_name"
    echo "=================================="
    
    local version
    version=$(grep "SENTINEL_MODULE_VERSION=" "$module_file" | head -n1 | cut -d'"' -f2)
    local description
    description=$(grep "SENTINEL_MODULE_DESCRIPTION=" "$module_file" | head -n1 | cut -d'"' -f2)
    local author
    author=$(grep "SENTINEL_MODULE_AUTHOR=" "$module_file" | head -n1 | cut -d'"' -f2)
    local dependencies
    dependencies=$(grep "SENTINEL_MODULE_DEPENDENCIES=" "$module_file" | head -n1 | cut -d'"' -f2)
    
    echo -e "Version:\t${version:-unknown}"
    echo -e "Author:\t\t${author:-unknown}"
    echo -e "Description:\t${description:-No description available}"
    echo -e "Dependencies:\t${dependencies:-none}"
    
    echo -e "\nStatus:"
    if grep -q "^${module_name}\$" "$HOME/.bash_modules"; then
        echo "  [Enabled at startup]"
    else
        echo "  [Not enabled at startup]"
    fi
    
    if [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "1" ]]; then
        echo "  [Loaded in current session]"
    elif [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "failed" ]]; then
        echo "  [Failed to load in current session]"
    else
        echo "  [Not loaded in current session]"
    fi
    
    echo -e "\nFunctions provided:"
    if [[ -x "$module_file" ]]; then
        grep -E "^function [a-zA-Z0-9_-]+\(\)|^[a-zA-Z0-9_-]+\(\)" "$module_file" | \
        sed -E 's/function ([a-zA-Z0-9_-]+)\(\)|\s*\{$|\s*\{|\(\)|\s*$/\1/g' | \
        while IFS= read -r func; do
            [[ -z "$func" ]] && continue
            echo "  - $func"
        done
    else
        echo "  (Cannot analyze: Module file is not executable)"
    fi
}

# Helper to create a new module with template content.
module_create() {
    local module_name="$1"
    local module_file="$SENTINEL_MODULES_PATH/$module_name.module"
    
    if [[ -z "$module_name" ]]; then
        echo "Error: Module name is required." 1>&2
        echo "Usage: module_create <module_name>"
        return 1
    fi
    
    if [[ -f "$module_file" ]]; then
        echo "Error: Module '$module_name' already exists at $module_file" 1>&2
        return 1
    fi
    
    # Create a basic template for the module (customize as needed).
    cat << 'EOF' > "$module_file"
#!/usr/bin/env bash
# SENTINEL_MODULE_VERSION="1.0.0"
# SENTINEL_MODULE_DESCRIPTION="Description for your module"
# SENTINEL_MODULE_AUTHOR="Your Name"
# SENTINEL_MODULE_DEPENDENCIES=""
EOF
    chmod +x "$module_file"
    
    echo "Module '$module_name' created at $module_file" 1>&2
    echo "Edit the file to implement your module functionality." 1>&2
    echo "To enable the module, run: module_enable $module_name" 1>&2
}

# --- Auto-population and Auto-loading Functions ---

# Auto-populate the module list file with all module files (.module) available.
auto_populate_module_list() {
    # Overwrite (or create) the modules list file.
    > "$HOME/.bash_modules"
    
    local module_file
    for module_file in "$SENTINEL_MODULES_PATH"/*.module; do
        [[ -e "$module_file" ]] || continue
        local module_name
        module_name=$(basename "$module_file" .module)
        echo "$module_name" >> "$HOME/.bash_modules"
    done
}

# Auto-load all module files found in the modules directory.
load_all_module_files() {
    local module_file
    for module_file in "$SENTINEL_MODULES_PATH"/*.module; do
        [[ -e "$module_file" ]] || continue
        local module_name
        module_name=$(basename "$module_file" .module)
        module_enable "$module_name" "0" "auto"
    done
}

# --- Legacy Backwards Compatibility Functions ---

bash_module() {
    echo "Warning: Using legacy function bash_module(). Consider switching to module_enable()." 1>&2
    module_enable "$1"
}

bash_list_modules() {
    echo "Warning: Using legacy function bash_list_modules(). Consider switching to module_list()." 1>&2
    module_list
}

# --- Startup: Auto-populate and Load Modules ---

# (Optionally) update the modules list.
auto_populate_module_list

# Auto-load all modules found in the modules directory.
load_all_module_files
