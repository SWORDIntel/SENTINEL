#!/usr/bin/env bash
# SENTINEL Module System
# Provides dynamic loading and management of bashrc extensions

# Define colors for prettier output
export RED="\033[0;31m"
export GREEN="\033[0;32m"
export YELLOW="\033[0;33m"
export BLUE="\033[0;34m"
export MAGENTA="\033[0;35m"
export CYAN="\033[0;36m"
export NC="\033[0m" # No Color

# Module directory path
export SENTINEL_MODULES_PATH=${U_MODULES_PATH:-"$HOME/.bash_modules.d"}

# Ensure module directory is properly set and exists
if [[ -z "$SENTINEL_MODULES_PATH" ]]; then
    # Fallback to standard location
    export SENTINEL_MODULES_PATH="$HOME/.bash_modules.d"
    ewarn "SENTINEL_MODULES_PATH was empty, reset to default $SENTINEL_MODULES_PATH"
fi

# Registry of loaded modules
declare -A SENTINEL_LOADED_MODULES

# Set quiet mode by default (set to 0 for verbose output)
export SENTINEL_QUIET_MODULES=${SENTINEL_QUIET_MODULES:-1}

# Initialize modules directory if it doesn't exist
if [[ ! -d "$SENTINEL_MODULES_PATH" ]]; then
    mkdir -p "$SENTINEL_MODULES_PATH"
    echo "Created modules directory: $SENTINEL_MODULES_PATH"
fi

# Check if list of modules file exists
if [[ ! -f "$HOME/.bash_modules" ]]; then
    touch "$HOME/.bash_modules"
fi

# Output functions with verbosity control
emsg() {
    [[ "$SENTINEL_QUIET_MODULES" != "1" ]] && echo "$@"
}

ewarn() {
    # Always show warnings
    echo "$@"
}

eerror() {
    # Always show errors
    echo "$@" >&2
}

# Module loading function with error handling and dependency resolution
module_enable() {
    local module_name="$1"
    local force="${2:-0}"
    local called_by="${3:-direct}"
    local module_file=""
    local debug_mode="${SENTINEL_DEBUG_MODULES:-0}"
    
    [[ "$debug_mode" == "1" ]] && echo "DEBUG: Attempting to load module '$module_name'" >&2
    
    # Check for both .sh and .module extensions
    if [[ -f "$SENTINEL_MODULES_PATH/$module_name.sh" ]]; then
        module_file="$SENTINEL_MODULES_PATH/$module_name.sh"
        [[ "$debug_mode" == "1" ]] && echo "DEBUG: Found .sh module at $module_file" >&2
    elif [[ -f "$SENTINEL_MODULES_PATH/$module_name.module" ]]; then
        module_file="$SENTINEL_MODULES_PATH/$module_name.module"
        [[ "$debug_mode" == "1" ]] && echo "DEBUG: Found .module at $module_file" >&2
    fi
    
    # Check if module is already loaded
    if [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "1" ]] && [[ "$force" != "1" ]]; then
        [[ "$called_by" == "direct" && "$SENTINEL_QUIET_MODULES" != "1" ]] && emsg "Module '$module_name' is already loaded."
        return 0
    fi
    
    # Check if module file exists
    if [[ -z "$module_file" || ! -f "$module_file" ]]; then
        if [[ "$called_by" == "direct" ]]; then
            eerror "Module '$module_name' not found."
            
            # Check for similar modules as suggestion
            local suggestions=$(find "$SENTINEL_MODULES_PATH" -name "*.sh" -o -name "*.module" | xargs -n1 basename | sed 's/\.sh$//' | sed 's/\.module$//' | grep -i "$module_name" || echo "")
            if [[ -n "$suggestions" ]]; then
                echo "Did you mean one of these?"
                echo "$suggestions" | while IFS= read -r suggestion; do
                    echo "  $suggestion"
                done
            fi
        fi
        return 1
    fi
    
    # Security: Verify module integrity if HMAC verification is enabled
    if [[ "${SENTINEL_VERIFY_MODULES:-0}" == "1" ]] && command -v openssl &>/dev/null; then
        [[ "$debug_mode" == "1" ]] && echo "DEBUG: HMAC verification enabled" >&2
        if [[ -f "$module_file.hmac" ]]; then
            # Use the HMAC key from environment or a default derived from machine-id
            local hmac_key="${SENTINEL_HMAC_KEY:-$(cat /etc/machine-id 2>/dev/null || echo "SENTINEL_DEFAULT_KEY")}"
            local calculated_hmac=$(openssl dgst -sha256 -hmac "$hmac_key" "$module_file" | cut -d' ' -f2)
            local stored_hmac=$(cat "$module_file.hmac" 2>/dev/null)
            
            [[ "$debug_mode" == "1" ]] && echo "DEBUG: HMAC verification - stored=$stored_hmac vs calculated=$calculated_hmac" >&2
            
            if [[ "$calculated_hmac" != "$stored_hmac" ]]; then
                eerror "Security warning: Module '$module_name' failed integrity verification"
                if [[ "$force" != "1" ]]; then
                    return 1
                else
                    ewarn "Loading potentially compromised module due to force flag"
                fi
            else
                [[ "$debug_mode" == "1" ]] && echo "DEBUG: HMAC verification passed" >&2
            fi
        elif [[ "${SENTINEL_REQUIRE_HMAC:-0}" == "1" && "$force" != "1" ]]; then
            eerror "Security warning: Module '$module_name' has no HMAC signature"
            return 1
        else
            [[ "$debug_mode" == "1" ]] && echo "DEBUG: No HMAC signature found, but not required" >&2
        fi
    fi
    
    # Security: Check for suspicious patterns in module
    if [[ "${SENTINEL_CHECK_MODULE_CONTENT:-1}" == "1" ]]; then
        local suspicious_patterns=(
            'curl.*\|.*sh'
            'wget.*\|.*sh'
            '>(bash|sh)'
            'eval.*\$\('
            'base64.*decode'
        )
        
        for pattern in "${suspicious_patterns[@]}"; do
            if grep -qE "$pattern" "$module_file"; then
                ewarn "Security warning: Module '$module_name' contains potentially unsafe patterns"
                ewarn "Review the module before loading or use force flag"
                if [[ "$force" != "1" ]]; then
                    return 1
                fi
                break
            fi
        done
    fi
    
    # Load module source to extract metadata without executing
    local dependencies=""
    if grep -q "SENTINEL_MODULE_DEPENDENCIES=" "$module_file"; then
        dependencies=$(grep "SENTINEL_MODULE_DEPENDENCIES=" "$module_file" | head -n1 | cut -d'"' -f2)
    fi
    
    # Process dependencies if any
    if [[ -n "$dependencies" ]]; then
        for dep in $dependencies; do
            if [[ "${SENTINEL_LOADED_MODULES[$dep]}" != "1" ]]; then
                emsg "Resolving dependency: $dep for $module_name"
                module_enable "$dep" "$force" "$module_name"
                
                # If dependency loading failed, abort
                if [[ $? -ne 0 ]]; then
                    eerror "Failed to load dependency '$dep' required by '$module_name'"
                    return 1
                fi
            fi
        done
    fi
    
    # Actually load the module
    if [[ -x "$module_file" || "$force" == "1" ]]; then
        # Mark as loading to detect circular dependencies
        SENTINEL_LOADED_MODULES["$module_name"]="loading"
        
        # Source the module
        if source "$module_file"; then
            SENTINEL_LOADED_MODULES["$module_name"]="1"
            
            # Add to enabled modules list if it's not already there
            if ! grep -q "^${module_name}\$" "$HOME/.bash_modules" && [[ "$called_by" == "direct" ]]; then
                echo "$module_name" >> "$HOME/.bash_modules"
                emsg "Module '$module_name' enabled and will be loaded on startup."
            fi
            
            # Only show success message if direct call and not in quiet mode
            [[ "$called_by" == "direct" && "$SENTINEL_QUIET_MODULES" != "1" ]] && emsg "Module '$module_name' loaded successfully."
            return 0
        else
            SENTINEL_LOADED_MODULES["$module_name"]="failed"
            eerror "Failed to load module '$module_name' - error in module code."
            return 1
        fi
    else
        eerror "Module file '$module_file' is not executable. Run: chmod +x '$module_file'"
        return 1
    fi
}

# Disable a module
module_disable() {
    local module_name="$1"
    
    # Check if module is in the enabled list
    if grep -q "^${module_name}\$" "$HOME/.bash_modules"; then
        # Remove from enabled list
        sed -i "/^${module_name}\$/d" "$HOME/.bash_modules"
        
        # If module is loaded in current session, mark it as unloaded
        # (can't actually unload it without starting a new session)
        if [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "1" ]]; then
            unset "SENTINEL_LOADED_MODULES[$module_name]"
            emsg "Module '$module_name' disabled. It will not be loaded in future sessions."
            emsg "Note: The module remains active in the current session."
        else
            emsg "Module '$module_name' disabled. It will not be loaded in future sessions."
        fi
        return 0
    else
        ewarn "Module '$module_name' is not enabled."
        return 1
    fi
}

# Sign a module with HMAC for integrity verification
module_sign() {
    local module_name="$1"
    local module_file=""
    
    # Check for both .sh and .module extensions
    if [[ -f "$SENTINEL_MODULES_PATH/$module_name.sh" ]]; then
        module_file="$SENTINEL_MODULES_PATH/$module_name.sh"
    elif [[ -f "$SENTINEL_MODULES_PATH/$module_name.module" ]]; then
        module_file="$SENTINEL_MODULES_PATH/$module_name.module"
    fi
    
    # Check if module file exists
    if [[ -z "$module_file" || ! -f "$module_file" ]]; then
        eerror "Module '$module_name' not found."
        return 1
    fi
    
    # Check if openssl is available
    if ! command -v openssl &>/dev/null; then
        eerror "openssl command not found. Cannot sign module."
        return 1
    fi
    
    # Use the HMAC key from environment or a default derived from machine-id
    local hmac_key="${SENTINEL_HMAC_KEY:-$(cat /etc/machine-id 2>/dev/null || echo "SENTINEL_DEFAULT_KEY")}"
    
    # Generate HMAC
    local hmac=$(openssl dgst -sha256 -hmac "$hmac_key" "$module_file" | cut -d' ' -f2)
    echo "$hmac" > "$module_file.hmac"
    
    # Set appropriate permissions
    chmod 600 "$module_file.hmac"
    
    emsg "Module '$module_name' signed successfully with HMAC."
    return 0
}

# List all modules with their status
module_list() {
    echo "SENTINEL Modules"
    echo "================"
    
    # Count the modules
    local total_modules=0
    local enabled_modules=0
    local loaded_modules=0
    local verified_modules=0
    
    # Get list of module files (both .sh and .module)
    local module_files=$(find "$SENTINEL_MODULES_PATH" \( -name "*.sh" -o -name "*.module" \) 2>/dev/null | sort)
    
    # Debug output
    if [[ -z "$module_files" ]]; then
        echo "Warning: No module files found in $SENTINEL_MODULES_PATH"
        echo "Module path exists: $(if [[ -d "$SENTINEL_MODULES_PATH" ]]; then echo "Yes"; else echo "No"; fi)"
        echo "Modules in directory: $(ls -1 "$SENTINEL_MODULES_PATH" 2>/dev/null | wc -l)"
    fi
    
    echo -e "\nAvailable modules:"
    echo "-----------------"
    
    # Process each module
    while IFS= read -r module_file; do
        [[ -z "$module_file" ]] && continue
        
        # Extract module name without extension (both .sh and .module)
        local module_name=$(basename "$module_file" | sed 's/\.sh$//' | sed 's/\.module$//')
        total_modules=$((total_modules + 1))
        
        # Get module description
        local description=""
        if grep -q "SENTINEL_MODULE_DESCRIPTION=" "$module_file" 2>/dev/null; then
            description=$(grep "SENTINEL_MODULE_DESCRIPTION=" "$module_file" | head -n1 | cut -d'"' -f2)
        else
            # Try to extract from header comment
            description=$(grep -A1 "# SENTINEL Module:" "$module_file" 2>/dev/null | tail -n1 | sed 's/# //')
            [[ "$description" == *"SENTINEL Module:"* ]] && description=""
        fi
        
        # Determine module status
        local status=" "
        local status_color="${NC}"
        
        # Check if enabled at startup
        if [[ -f "$HOME/.bash_modules" ]] && grep -q "^${module_name}\$" "$HOME/.bash_modules" 2>/dev/null; then
            status="E"
            status_color="${GREEN}"
            enabled_modules=$((enabled_modules + 1))
        fi
        
        # Check if currently loaded
        if [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "1" ]]; then
            status="${status}L"
            status_color="${GREEN}"
            loaded_modules=$((loaded_modules + 1))
        elif [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "failed" ]]; then
            status="${status}F"
            status_color="${RED}"
        fi
        
        # Check HMAC verification status
        local verify_status=""
        if [[ -f "$module_file.hmac" ]]; then
            if [[ "${SENTINEL_VERIFY_MODULES:-0}" == "1" ]] && command -v openssl &>/dev/null; then
                local hmac_key="${SENTINEL_HMAC_KEY:-$(cat /etc/machine-id 2>/dev/null || echo "SENTINEL_DEFAULT_KEY")}"
                local calculated_hmac=$(openssl dgst -sha256 -hmac "$hmac_key" "$module_file" | cut -d' ' -f2)
                local stored_hmac=$(cat "$module_file.hmac" 2>/dev/null)
                
                if [[ "$calculated_hmac" == "$stored_hmac" ]]; then
                    status="${status}V"
                    verified_modules=$((verified_modules + 1))
                else
                    status="${status}!"
                fi
            else
                status="${status}S"  # Signed but not verified
            fi
        fi
        
        # Format status indicator
        if [[ "$status" == " " ]]; then
            status="  "
        else
            status="[${status}]"
        fi
        
        # Display module info
        echo -e "${status_color}${status}${NC} ${module_name}\t${description:0:50}${description:50:+...}"
    done <<< "$module_files"
    
    echo -e "\nStatus: [E]=Enabled at startup, [L]=Loaded in current session, [F]=Failed to load"
    echo -e "        [V]=Verified, [S]=Signed, [!]=Signature invalid"
    echo -e "Summary: $total_modules total, $enabled_modules enabled, $loaded_modules loaded, $verified_modules verified"
    
    # Add improved configuration guidance
    echo -e "\n${YELLOW}Module Management Commands:${NC}"
    echo -e "  ${CYAN}module_enable${NC} <module_name>        - Enable and load a module"
    echo -e "  ${CYAN}module_disable${NC} <module_name>       - Disable a module"
    echo -e "  ${CYAN}module_toggle${NC} <module_name> <on|off> - Toggle module state (easier to use)"
    echo -e "  ${CYAN}module_status${NC} <module_name>        - Check detailed status of a module"
    echo -e "  ${CYAN}module_sign${NC} <module_name>          - Sign a module with HMAC"
    echo -e "  ${CYAN}module_menu${NC}                      - Interactive module management menu"
    echo -e "  ${CYAN}module_verbose${NC} <on|off>          - Toggle verbose output mode"
    echo -e "  ${CYAN}module_debug${NC} <on|off>            - Toggle debug output mode"
    
    echo -e "\n${YELLOW}Module Configuration in ~/.bashrc.postcustom:${NC}"
    echo -e "You can also configure modules by setting variables in your ${CYAN}~/.bashrc.postcustom${NC} file:"
    echo -e "  ${GREEN}export SENTINEL_MODULENAME_ENABLED=1${NC}  # Enable a specific module"
    echo -e "  ${GREEN}export SENTINEL_MODULENAME_ENABLED=0${NC}  # Disable a specific module"
    
    echo -e "\n${YELLOW}Global Configuration Options:${NC}"
    echo -e "  ${GREEN}export SENTINEL_QUIET_MODULES=1${NC}       # Silent module loading (default)"
    echo -e "  ${GREEN}export SENTINEL_QUIET_MODULES=0${NC}       # Verbose module loading"
    echo -e "  ${GREEN}export SENTINEL_DEBUG_MODULES=1${NC}       # Enable detailed debug output"
    echo -e "  ${GREEN}export SENTINEL_VERIFY_MODULES=1${NC}      # Enable HMAC verification"
    echo -e "  ${GREEN}export SENTINEL_REQUIRE_HMAC=1${NC}        # Require HMAC signatures"
    echo -e "  ${GREEN}export SENTINEL_CHECK_MODULE_CONTENT=1${NC} # Check for suspicious patterns"
    echo -e "  ${GREEN}export SENTINEL_HMAC_KEY='your-key'${NC}   # Custom HMAC key for signing"
}

# Function to control verbosity
module_verbose() {
    if [[ "$1" == "on" ]]; then
        export SENTINEL_QUIET_MODULES=0
        echo "Module verbose mode ON"
    elif [[ "$1" == "off" ]]; then
        export SENTINEL_QUIET_MODULES=1
        echo "Module verbose mode OFF"
    else
        echo "Current module verbose mode: $([[ "$SENTINEL_QUIET_MODULES" == "1" ]] && echo "OFF" || echo "ON")"
        echo "Usage: module_verbose [on|off]"
    fi
}

# Function to enable or disable module debugging
module_debug() {
    if [[ "$1" == "on" ]]; then
        export SENTINEL_DEBUG_MODULES=1
        echo "Module debug mode ON"
    elif [[ "$1" == "off" ]]; then
        export SENTINEL_DEBUG_MODULES=0
        echo "Module debug mode OFF"
    else
        echo "Current module debug mode: $([[ "${SENTINEL_DEBUG_MODULES:-0}" == "1" ]] && echo "ON" || echo "OFF")"
        echo "Usage: module_debug [on|off]"
    fi
}

# Diagnostic function to check module system health
module_diagnose() {
    echo "SENTINEL Module System Diagnostics"
    echo "================================="
    
    # Check module directory
    echo -e "\nModule directory:"
    echo "Path: $SENTINEL_MODULES_PATH"
    echo "Exists: $(if [[ -d "$SENTINEL_MODULES_PATH" ]]; then echo "Yes"; else echo "No"; fi)"
    echo "Permissions: $(ls -ld "$SENTINEL_MODULES_PATH" 2>/dev/null || echo "Cannot access directory")"
    
    # Count modules
    echo -e "\nModule counts:"
    echo "Module files (.sh): $(find "$SENTINEL_MODULES_PATH" -name "*.sh" 2>/dev/null | wc -l)"
    echo "Module files (.module): $(find "$SENTINEL_MODULES_PATH" -name "*.module" 2>/dev/null | wc -l)"
    echo "Total module files: $(find "$SENTINEL_MODULES_PATH" \( -name "*.sh" -o -name "*.module" \) 2>/dev/null | wc -l)"
    echo "Currently loaded modules: ${#SENTINEL_LOADED_MODULES[@]}"
    
    # List enabled modules
    echo -e "\nEnabled modules (from ~/.bash_modules):"
    if [[ -f "$HOME/.bash_modules" ]]; then
        grep -v "^#\|^$" "$HOME/.bash_modules" | nl || echo "None"
    else
        echo "File ~/.bash_modules does not exist"
    fi
    
    # Environment
    echo -e "\nEnvironment settings:"
    echo "SENTINEL_QUIET_MODULES=${SENTINEL_QUIET_MODULES:1}"
    echo "SENTINEL_DEBUG_MODULES=${SENTINEL_DEBUG_MODULES:0}"
    echo "SENTINEL_VERIFY_MODULES=${SENTINEL_VERIFY_MODULES:0}"
    echo "SENTINEL_REQUIRE_HMAC=${SENTINEL_REQUIRE_HMAC:0}"
    echo "SENTINEL_CHECK_MODULE_CONTENT=${SENTINEL_CHECK_MODULE_CONTENT:-1}"
    
    # Shell info
    echo -e "\nShell information:"
    echo "Shell: $SHELL"
    echo "Bash version: $BASH_VERSION"
    
    echo -e "\nTo enable debug mode: module_debug on"
    echo "To enable verbose mode: module_verbose on"
}

# Load all enabled modules on startup with minimal output
_load_enabled_modules() {
    if [[ -f "$HOME/.bash_modules" ]]; then
        # Only show this message in verbose mode
        [[ "$SENTINEL_QUIET_MODULES" != "1" ]] && echo "Loading modules from $HOME/.bash_modules..."
        
        # Count for summary
        local enabled_count=0
        local success_count=0
        local total_count=$(grep -v "^#\|^$" "$HOME/.bash_modules" | wc -l)
        
        # Create progress bar if not in quiet mode and not in minimal terminal
        local show_progress=0
        if [[ "$SENTINEL_QUIET_MODULES" != "1" && -t 1 && $(tput cols) -gt 60 ]]; then
            show_progress=1
        fi
        
        # Initialize progress display
        if [[ $show_progress -eq 1 && $total_count -gt 0 ]]; then
            echo -ne "Loading modules [          ] 0%\r"
        fi
        
        while IFS= read -r module; do
            [[ -z "$module" || "$module" =~ ^# ]] && continue
            enabled_count=$((enabled_count + 1))
            
            # Update progress
            if [[ $show_progress -eq 1 ]]; then
                local percent=$((enabled_count * 100 / total_count))
                local bar_size=$((enabled_count * 10 / total_count))
                local bar=$(printf "%${bar_size}s" | tr ' ' '#')
                local spaces=$(printf "%$((10 - bar_size))s")
                echo -ne "Loading modules [${bar}${spaces}] ${percent}%\r"
            fi
            
            # Load module
            module_enable "$module" "0" "startup"
            [[ $? -eq 0 ]] && success_count=$((success_count + 1))
        done < "$HOME/.bash_modules"
        
        # Clear progress line and show summary
        if [[ $show_progress -eq 1 ]]; then
            echo -ne "                                        \r"
        fi
        
        # Show summary only in verbose mode
        if [[ "$SENTINEL_QUIET_MODULES" != "1" ]]; then
            if [[ $success_count -lt $enabled_count ]]; then
                echo -e "${YELLOW}Loaded $success_count/$enabled_count modules${NC}"
                
                # List failed modules if any
                if [[ $success_count -lt $enabled_count ]]; then
                    echo "Failed modules:"
                    for module in "${!SENTINEL_LOADED_MODULES[@]}"; do
                        if [[ "${SENTINEL_LOADED_MODULES[$module]}" == "failed" ]]; then
                            echo -e " ${RED}*${NC} $module"
                        fi
                    done
                fi
            else
                echo -e "${GREEN}Loaded $success_count/$enabled_count modules${NC}"
            fi
        fi
    fi
}

# Function to toggle a module on or off
module_toggle() {
    local module_name="$1"
    local action="$2"
    local force="${3:-0}"
    
    if [[ -z "$module_name" || -z "$action" ]]; then
        echo "Usage: module_toggle <module_name> <on|off> [force]"
        echo "  Example: module_toggle obfuscate on"
        echo "  Example: module_toggle sentinel_chat off"
        return 1
    fi
    
    case "$action" in
        on|enable|1)
            module_enable "$module_name" "$force"
            return $?
            ;;
        off|disable|0)
            module_disable "$module_name"
            return $?
            ;;
        *)
            echo "Invalid action: $action"
            echo "Valid actions: on, enable, 1, off, disable, 0"
            return 1
            ;;
    esac
}

# Register backwards compatibility functions
bash_module() {
    ewarn "Using legacy function bash_module(). Consider switching to module_enable()."
    module_enable "$1"
}

bash_list_modules() {
    ewarn "Using legacy function bash_list_modules(). Consider switching to module_list()."
    module_list
}

# Module configuration
# Configure modules in ~/.bashrc.postcustom, not here
# Example in ~/.bashrc.postcustom:
#   export SENTINEL_OSINT_ENABLED=1       # Enable OSINT module
#   export SENTINEL_OBFUSCATE_ENABLED=0   # Disable obfuscation module

# Ensure compatibility with bashrc module registry
if [[ -n "${SENTINEL_MODULES+x}" ]]; then
    # Update the main SENTINEL_MODULES registry if it exists
    for module_name in "${!SENTINEL_LOADED_MODULES[@]}"; do
        if [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "1" ]]; then
            SENTINEL_MODULES["$module_name"]=1
        fi
    done
fi

# Load modules on startup
_load_enabled_modules

# Load all modules from the modules directory
if [[ -d "$SENTINEL_MODULES_PATH" ]]; then
    for module_file in "$SENTINEL_MODULES_PATH"/*.module; do
        if [[ -f "$module_file" && -r "$module_file" ]]; then
            module_name=$(basename "$module_file" .module)
            module_enable "$module_name" "0" "startup"
        fi
    done
fi

# Additional modules can be loaded here for custom configurations

# Interactive menu for module management
module_menu() {
    local NORMAL=$(tput sgr0)
    local BOLD=$(tput bold)
    local RED=$(tput setaf 1)
    local GREEN=$(tput setaf 2)
    local YELLOW=$(tput setaf 3)
    local BLUE=$(tput setaf 4)
    local MAGENTA=$(tput setaf 5)
    local CYAN=$(tput setaf 6)
    local WHITE=$(tput setaf 7)
    
    # Check if we're in a proper terminal
    if [ ! -t 0 ] || [ ! -t 1 ]; then
        echo "Error: Interactive menu requires a terminal."
        return 1
    fi
    
    while true; do
        clear
        echo -e "${BOLD}${BLUE}SENTINEL Module Management${NORMAL}"
        echo -e "${BOLD}${BLUE}==========================${NORMAL}\n"
        
        # Display module counts
        local total_count=$(find "$SENTINEL_MODULES_PATH" \( -name "*.sh" -o -name "*.module" \) 2>/dev/null | wc -l)
        local enabled_count=$(grep -v "^#\|^$" "$HOME/.bash_modules" 2>/dev/null | wc -l)
        local loaded_count=${#SENTINEL_LOADED_MODULES[@]}
        
        echo -e "${BOLD}Modules:${NORMAL} $total_count total, $enabled_count enabled, $loaded_count loaded\n"
        
        # Show system status
        echo -e "${BOLD}System Status:${NORMAL}"
        echo -e "  Verbose Mode: $([ "$SENTINEL_QUIET_MODULES" = "0" ] && echo "${GREEN}ON${NORMAL}" || echo "${RED}OFF${NORMAL}")"
        echo -e "  Debug Mode: $([ "${SENTINEL_DEBUG_MODULES:-0}" = "1" ] && echo "${GREEN}ON${NORMAL}" || echo "${RED}OFF${NORMAL}")"
        echo -e "  HMAC Verification: $([ "${SENTINEL_VERIFY_MODULES:-0}" = "1" ] && echo "${GREEN}ON${NORMAL}" || echo "${RED}OFF${NORMAL}")"
        echo -e "  HMAC Required: $([ "${SENTINEL_REQUIRE_HMAC:-0}" = "1" ] && echo "${GREEN}ON${NORMAL}" || echo "${RED}OFF${NORMAL}")"
        echo -e "  Content Security Check: $([ "${SENTINEL_CHECK_MODULE_CONTENT:-1}" = "1" ] && echo "${GREEN}ON${NORMAL}" || echo "${RED}OFF${NORMAL}")\n"
        
        # Show menu options
        echo -e "${BOLD}Options:${NORMAL}"
        echo -e "  ${BOLD}1)${NORMAL} ${CYAN}List Modules${NORMAL}"
        echo -e "  ${BOLD}2)${NORMAL} ${CYAN}Enable Module${NORMAL}"
        echo -e "  ${BOLD}3)${NORMAL} ${CYAN}Disable Module${NORMAL}"
        echo -e "  ${BOLD}4)${NORMAL} ${CYAN}Sign Module${NORMAL}"
        echo -e "  ${BOLD}5)${NORMAL} ${CYAN}Toggle Verbose Mode${NORMAL} ($([ "$SENTINEL_QUIET_MODULES" = "0" ] && echo "ON" || echo "OFF"))"
        echo -e "  ${BOLD}6)${NORMAL} ${CYAN}Toggle Debug Mode${NORMAL} ($([ "${SENTINEL_DEBUG_MODULES:-0}" = "1" ] && echo "ON" || echo "OFF"))"
        echo -e "  ${BOLD}7)${NORMAL} ${CYAN}System Diagnostics${NORMAL}"
        echo -e "  ${BOLD}q)${NORMAL} ${CYAN}Quit${NORMAL}\n"
        
        read -p "Enter option: " choice
        
        case "$choice" in
            1) # List modules
                clear
                module_list
                echo
                read -p "Press Enter to continue..."
                ;;
            2) # Enable module
                read -p "Enter module name to enable: " module_name
                if [[ -n "$module_name" ]]; then
                    module_enable "$module_name"
                fi
                read -p "Press Enter to continue..."
                ;;
            3) # Disable module
                read -p "Enter module name to disable: " module_name
                if [[ -n "$module_name" ]]; then
                    module_disable "$module_name"
                fi
                read -p "Press Enter to continue..."
                ;;
            4) # Sign module
                read -p "Enter module name to sign: " module_name
                if [[ -n "$module_name" ]]; then
                    module_sign "$module_name"
                fi
                read -p "Press Enter to continue..."
                ;;
            5) # Toggle verbose mode
                if [[ "$SENTINEL_QUIET_MODULES" = "1" ]]; then
                    module_verbose on
                else
                    module_verbose off
                fi
                read -p "Press Enter to continue..."
                ;;
            6) # Toggle debug mode
                if [[ "${SENTINEL_DEBUG_MODULES:-0}" = "0" ]]; then
                    module_debug on
                else
                    module_debug off
                fi
                read -p "Press Enter to continue..."
                ;;
            7) # System diagnostics
                clear
                module_diagnose
                echo
                read -p "Press Enter to continue..."
                ;;
            q|Q|quit|exit)
                clear
                return 0
                ;;
            *)
                echo -e "${RED}Invalid option${NORMAL}"
                read -p "Press Enter to continue..."
                ;;
        esac
    done
}

# Check status of a specific module
module_status() {
    local module_name="$1"
    
    if [[ -z "$module_name" ]]; then
        echo "Usage: module_status <module_name>"
        return 1
    fi
    
    echo -e "${BOLD}Module Status: ${module_name}${NC}"
    echo "------------------------"
    
    # Check if module file exists
    local module_file=""
    local file_status="Not found"
    local file_path=""
    
    if [[ -f "$SENTINEL_MODULES_PATH/$module_name.sh" ]]; then
        module_file="$SENTINEL_MODULES_PATH/$module_name.sh"
        file_status="Found (.sh)"
        file_path="$module_file"
    elif [[ -f "$SENTINEL_MODULES_PATH/$module_name.module" ]]; then
        module_file="$SENTINEL_MODULES_PATH/$module_name.module"
        file_status="Found (.module)"
        file_path="$module_file"
    fi
    
    echo "File: $file_status"
    [[ -n "$file_path" ]] && echo "Path: $file_path"
    
    # Check if enabled at startup
    local enabled="No"
    if [[ -f "$HOME/.bash_modules" ]] && grep -q "^${module_name}\$" "$HOME/.bash_modules" 2>/dev/null; then
        enabled="Yes"
    fi
    echo "Enabled at startup: $enabled"
    
    # Check if module is loaded in current session
    local loaded="No"
    if [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "1" ]]; then
        loaded="Yes"
    elif [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "failed" ]]; then
        loaded="Failed to load"
    elif [[ "${SENTINEL_LOADED_MODULES[$module_name]}" == "loading" ]]; then
        loaded="Currently loading"
    fi
    echo "Loaded in current session: $loaded"
    
    # Check HMAC status
    if [[ -n "$module_file" ]]; then
        if [[ -f "$module_file.hmac" ]]; then
            echo "HMAC signature: Present"
            
            if [[ "${SENTINEL_VERIFY_MODULES:-0}" == "1" ]] && command -v openssl &>/dev/null; then
                local hmac_key="${SENTINEL_HMAC_KEY:-$(cat /etc/machine-id 2>/dev/null || echo "SENTINEL_DEFAULT_KEY")}"
                local calculated_hmac=$(openssl dgst -sha256 -hmac "$hmac_key" "$module_file" | cut -d' ' -f2)
                local stored_hmac=$(cat "$module_file.hmac" 2>/dev/null)
                
                if [[ "$calculated_hmac" == "$stored_hmac" ]]; then
                    echo "HMAC verification: Valid"
                else
                    echo "HMAC verification: Invalid (signature mismatch)"
                fi
            else
                echo "HMAC verification: Not verified (verification disabled)"
            fi
        else
            echo "HMAC signature: Missing"
        fi
    fi
    
    # Check module permissions
    if [[ -n "$module_file" ]]; then
        local perms=$(ls -l "$module_file" | awk '{print $1}')
        local is_executable=$(if [[ -x "$module_file" ]]; then echo "Yes"; else echo "No"; fi)
        echo "Permissions: $perms"
        echo "Executable: $is_executable"
    fi
    
    # Get module description and dependencies
    if [[ -n "$module_file" ]]; then
        local description=""
        local dependencies=""
        
        if grep -q "SENTINEL_MODULE_DESCRIPTION=" "$module_file" 2>/dev/null; then
            description=$(grep "SENTINEL_MODULE_DESCRIPTION=" "$module_file" | head -n1 | cut -d'"' -f2)
            echo "Description: $description"
        fi
        
        if grep -q "SENTINEL_MODULE_DEPENDENCIES=" "$module_file" 2>/dev/null; then
            dependencies=$(grep "SENTINEL_MODULE_DEPENDENCIES=" "$module_file" | head -n1 | cut -d'"' -f2)
            echo "Dependencies: $dependencies"
        fi
    fi
    
    # Module control help
    echo -e "\nCommands to control this module:"
    echo "  module_enable $module_name     - Enable and load the module"
    echo "  module_disable $module_name    - Disable the module"
    echo "  module_toggle $module_name on  - Enable the module (alternative)"
    echo "  module_toggle $module_name off - Disable the module (alternative)"
    echo "  module_sign $module_name       - Sign the module with HMAC"
}